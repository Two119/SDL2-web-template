#include "core_funcs.hpp"
Sound clicksound;
Spritesheet button_sprites;
class Button {
    public:
    int current[2] = {0, 0};
    bool clicked = false;
    SDL_Rect result;
    SDL_Rect rect;
    SDL_Rect src_rect;
    int pos[2];
    void init(int pos_[2]){
        pos[0] = pos_[0];
        pos[1] = pos_[1];
        rect.w = getsize(button_sprites.get(current)).x;
        rect.h =  getsize(button_sprites.get(current)).y;
        src_rect.w =  getsize(button_sprites.get(current)).x;
        src_rect.h =  getsize(button_sprites.get(current)).y;
        src_rect.x = 0;
        src_rect.y = 0;
        rect.x = pos[0];
        rect.y = pos[1];
    }
    void update(auto func){
        SDL_RenderCopy(renderer, button_sprites.get(current), &src_rect, &rect);
        if (SDL_PointInRect(&mousepos, &rect) == SDL_TRUE){
            current[0] = 1;
            if (button_state&SDL_BUTTON(1)){
                wrapper(func, 0);
                if (!clicked)  clicksound.play();
                clicked = true;
                return;
            }
            clicked = false;
        }
        else {
            current[0] = 0;
        }
    }
};
class Slider {
    public:
    int pos[2];
    SDL_Texture *bar_tex;
    SDL_Texture *slider_tex;
    SDL_Rect bar_rect;
    SDL_Rect slider_rect;
    SDL_Rect dstbar;
    SDL_Rect dstslider;
    int value;
    double offset;
    int min;
    int max;
    bool keyboard_controlled;
    void init(int pos_[2], int max_ = 110, int min_=0, bool key = false){
        offset = min_;
        value = min_/10;
        max = max_;
        min = min_;
        pos[0] = pos_[0];
        pos[1] = pos_[1];
        keyboard_controlled = key;
        bar_tex = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, 110, 20);
        slider_tex = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, 10, 40);
        bar_rect.x = 0;
        bar_rect.y = 0;
        bar_rect.w = 110;
        bar_rect.h = 20;
        slider_rect.x = 0;
        slider_rect.y = 0;
        slider_rect.w = 10;
        slider_rect.h = 40;
        dstslider.x = pos[0]+min_;
        dstslider.y = pos[1];
        dstslider.w = 10;
        dstslider.h = 40;
        dstbar.x = pos[0];
        dstbar.y = pos[1]+10;
        dstbar.w = 110;
        dstbar.h = 20;
        SDL_SetRenderTarget(renderer, bar_tex);
        SDL_SetTextureBlendMode(bar_tex, SDL_BLENDMODE_BLEND);
        SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);
        SDL_RenderFillRect(renderer, &bar_rect);
        SDL_SetRenderTarget(renderer, slider_tex);
        SDL_SetTextureBlendMode(slider_tex, SDL_BLENDMODE_BLEND);
        SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
        SDL_RenderFillRect(renderer, &slider_rect);
        SDL_SetRenderTarget(renderer, NULL);
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    }
    void update(){
        SDL_RenderCopy(renderer, bar_tex, &bar_rect, &dstbar);
        SDL_RenderCopy(renderer, slider_tex, &slider_rect, &dstslider);
        if (SDL_PointInRect(&mousepos, &dstbar) == SDL_TRUE && (mouse_pos[0]<pos[0]+max) && (mouse_pos[0]>pos[0]+min)){
            if (button_state&SDL_BUTTON(1)){
                dstslider.x = mouse_pos[0];
                offset = mouse_pos[0]-pos[0];
                value = offset/10;
            }
        }
        if (keyboard_controlled){
            if (keyboard_state[SDL_SCANCODE_RIGHT] && offset<84.5){
                offset+=0.75;
            }
            if (keyboard_state[SDL_SCANCODE_LEFT] && offset>10.5){
                offset-=0.75;
            }
            dstslider.x = pos[0]+offset;
            value = offset/10;
        }
        //cout << offset << ", " << value << endl;
    }
};#include "SDL2/SDL.h"
#include "SDL2/SDL_image.h"
#include "SDL2/SDL_mixer.h"
#include "SDL2/SDL_ttf.h"
#include "effolkronium/random.hpp"
#include "iostream"
#include "memory"
#include "string"
#include "cmath"
#include "vector"
#include "functional"
#include "SDL2_rotozoom.c"
#include "emscripten.h"
using namespace std;
using Random = effolkronium::random_static;
namespace base_variables {
    int mouse_pos[2];
    SDL_Point mousepos;
    const Uint8 *keyboard_state;
    SDL_Window *win = SDL_CreateWindow("SDL", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1280, 720, SDL_RENDERER_ACCELERATED);
    SDL_Renderer *renderer = SDL_CreateRenderer(win, -1, SDL_RENDERER_ACCELERATED);
    SDL_Rect window_rect;
    bool playing = true;
    SDL_Event event;
    Uint32 black = (255<<24) + (int(0)<<16) + (int(0)<<8) + int(0);
    Uint32 white = (255<<24) + (int(255)<<16) + (int(255)<<8) + int(255);
    Uint32 red = (255<<24) + (int(255)<<16) + (int(0)<<8) + int(0);
    Uint32 green = (255<<24) + (int(0)<<16) + (int(255)<<8) + int(0);
    Uint32 blue = (255<<24) + (int(0)<<16) + (int(0)<<8) + int(255);
    SDL_Surface *window_surface;
    Uint32 button_state;
    int FRAMES_PER_SECOND = 60;
    int framestart;
    int frametime;
    int framedelay = ( 1000 / FRAMES_PER_SECOND );
};
using namespace base_variables;
SDL_Surface * scale_surface(SDL_Surface *surf, float factor=4.0){
    return zoomSurface(surf, factor, factor, SMOOTHING_OFF);
}
SDL_Surface * rotate_surface(SDL_Surface *surf, double angle){
    return rotozoomSurface(surf, angle, 1.00, SMOOTHING_OFF);
}
SDL_Point getsize(SDL_Texture *texture) {
    SDL_Point size;
    SDL_QueryTexture(texture, NULL, NULL, &size.x, &size.y);
    return size;
}
SDL_Color get_at(SDL_Surface* pSurface, const int X, const int Y)
{
  // Bytes per pixel
  const Uint8 Bpp = pSurface->format->BytesPerPixel;

  /*
  Retrieve the address to a specific pixel
  pSurface->pixels  = an array containing the SDL_Surface' pixels
  pSurface->pitch       = the length of a row of pixels (in bytes)
  X and Y               = the offset on where on the image to retrieve the pixel; (0, 0) is the upper left corner
  */
  Uint8* pPixel = (Uint8*)pSurface->pixels + Y * pSurface->pitch + X * Bpp;

  Uint32 PixelData = *(Uint32*)pPixel;

  SDL_Color Color = {0x00, 0x00, 0x00, SDL_ALPHA_OPAQUE};

  // Retrieve the RGB values of the specific pixel
  SDL_GetRGB(PixelData, pSurface->format, &Color.r, &Color.g, &Color.b);

  return Color;
}
class Image{
    public:
    SDL_Rect srcrect;
    SDL_Rect dstrect;
    SDL_Texture* tex;
    SDL_Surface* tex_surf;
    void init(SDL_Surface* tex_, Uint32 colorkey = black, bool set = true){
        tex_surf = tex_;         
        if (set){SDL_SetColorKey(tex_surf, SDL_TRUE, colorkey);}
        tex = SDL_CreateTextureFromSurface(renderer, tex_surf);
        srcrect.x = 0;
        srcrect.y = 0;
        srcrect.w = tex_surf->w;
        srcrect.h = tex_surf->h;
        dstrect.w = tex_surf->w;
        dstrect.h = tex_surf->h;
    }
    void init_tex(SDL_Texture* surf){
        tex=surf;
        srcrect.x = 0;
        srcrect.y = 0;
        dstrect.w = getsize(surf).x; 
        dstrect.h = getsize(surf).y; 
        srcrect.w = getsize(surf).x;
        srcrect.h = getsize(surf).y; 
    }
    void blit(int pos[2]){
        dstrect.x = pos[0];
        dstrect.y = pos[1];
        SDL_RenderCopy(renderer, tex, &srcrect, &dstrect);
    }
    SDL_Rect get_src(){
        return srcrect;
    }
    SDL_Rect get_dst(){
        return dstrect;
    }
};
Image scale_image(Image img, float factor=4.0){
    Image new_img;
    new_img.init(zoomSurface(img.tex_surf, factor, factor, SMOOTHING_OFF));
    return new_img;
}
Image rotate_image(Image img, double angle){
    Image new_img;
    new_img.init(rotozoomSurface(img.tex_surf, angle, 1.00, SMOOTHING_OFF));
    return new_img;
}
void SDL_RenderOnTexture(SDL_Texture *src, SDL_Texture *dst, SDL_Rect dstrect, SDL_Rect srcrect){
    SDL_SetRenderTarget(renderer, dst);
    SDL_SetTextureBlendMode(dst, SDL_BLENDMODE_BLEND);
    SDL_RenderCopy(renderer, src, &srcrect, &dstrect);
    SDL_SetRenderTarget(renderer, NULL);
}
class Spritesheet{
    public:
    int size[2] = {0, 0};
    vector<vector<SDL_Texture *>> sheet;
    void init(SDL_Surface* sheet_, int size_[2], Uint32 colorkey = black, int spacing=0){
        size[0] = sheet_->w/size_[0];
        size[1] = sheet_->h/size_[1];
        SDL_Rect srcrect;
        srcrect.w = size[0];
        srcrect.h = size[1];
        SDL_Rect dstrect;
        dstrect.w = size[0];
        dstrect.h = size[1];
        dstrect.x = 0;
        dstrect.y = 0;
        vector<SDL_Texture *> vec = {};
        SDL_Texture *sheet_tex = SDL_CreateTextureFromSurface(renderer, sheet_);
        for (int i = 0; i < size_[1]; i++){
            sheet.push_back(vec);
            for (int j = 0; j < size_[0]; j++){
                SDL_Texture *surf = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, size[0]-spacing, size[1]-spacing);
                srcrect.x = (size[0]*j)+spacing;
                srcrect.y = (size[1]*i)+spacing;
                SDL_SetRenderTarget(renderer, surf);
                SDL_SetTextureBlendMode(surf, SDL_BLENDMODE_BLEND);
                SDL_RenderCopy(renderer, sheet_tex, &srcrect, &dstrect);
                sheet[i].push_back(surf);
            }
        }
        SDL_SetRenderTarget(renderer, NULL);
    }
    SDL_Texture * get(int loc[2]){
        return sheet[loc[1]][loc[0]];
    }
};
class Surf_Spritesheet{
    public:
    int size[2] = {0, 0};
    vector<vector<SDL_Surface *>> sheet;
    void init(SDL_Surface* sheet_, int size_[2], Uint32 colorkey = black, int spacing=0){
        size[0] = sheet_->w/size_[0];
        size[1] = sheet_->h/size_[1];
        SDL_Rect srcrect;
        srcrect.w = size[0];
        srcrect.h = size[1];
        SDL_Rect dstrect;
        dstrect.w = size[0];
        dstrect.h = size[1];
        dstrect.x = 0;
        dstrect.y = 0;
        vector<SDL_Surface *> vec = {};
        for (int i = 0; i < size_[1]; i++){
            sheet.push_back(vec);
            for (int j = 0; j < size_[0]; j++){
                SDL_Surface *surf = SDL_CreateRGBSurface(0,size[0]-spacing,size[1]-spacing,32,0,0,0,SDL_ALPHA_OPAQUE);
                srcrect.x = (size[0]*j)+spacing;
                srcrect.y = (size[1]*i)+spacing;
                SDL_BlitSurface(sheet_, &srcrect, surf, &dstrect);
                SDL_SetColorKey(surf, SDL_TRUE, colorkey);
                sheet[i].push_back(surf);
            }
        }
    }
    SDL_Surface * get(int loc[2]){
        return sheet[loc[1]][loc[0]];
    }
};
class Sound {
    public:
    int audio_rate = 22050;
    Uint16 audio_format = AUDIO_S16SYS; 
    int audio_channels = 2; 
    int audio_buffers = 4096;
    Mix_Chunk *sound = NULL;
    int channel;
    int result;
    void init(const char * filename){
        result = Mix_OpenAudio(audio_rate, audio_format, audio_channels, audio_buffers);
        result = Mix_AllocateChannels(4);
        sound = Mix_LoadWAV(filename);
    }
    void play(int channel = 0){
        channel = Mix_PlayChannel(channel, sound, 0);
    }
};
class Text{
    public:
    TTF_Font *font;
    SDL_Texture* fontSurface;
    SDL_Color fColor;
    SDL_Rect fontRect;
    void init(const char*filename, int fontsize){
        font = TTF_OpenFont(filename, fontsize);
        fColor.r = 255;
        fColor.g = 255;
        fColor.b = 255;
    }
    void render(const char *c, int pos[2]){
        fontSurface = SDL_CreateTextureFromSurface(renderer, TTF_RenderText_Solid(font, c, fColor));
        fontRect.x = pos[0];
        fontRect.y = pos[1];
        fontRect.w = getsize(fontSurface).x;
        fontRect.h = getsize(fontSurface).y;
        SDL_RenderCopy(renderer, fontSurface, NULL, &fontRect);
    }

};
class Sprite{
    public:
    vector<SDL_Rect> outline_rects;
    Image image;
    Uint32 colkey;
    int position[2];
    vector<vector<int>> outline;
    double scal;
    void init(SDL_Surface *img, int pos[2], double scale = 1, SDL_Color colorkey = {255, 255, 255}){
        scal = scale;
        colkey = (255<<24) + (int(colorkey.b)<<16) + (int(colorkey.g)<<8) + int(colorkey.r);
        image.init(scale_surface(img, scale), colkey);
        bool on_border = false;
        SDL_Rect rec;
        rec.w = scale;
        rec.h = scale;
        for (int j=0; j<img->h; j=j+1){
            for(int i=0; i<img->w; i=i+1){
                on_border = false;
                if (!(get_at(img, i, j).r==colorkey.r && get_at(img, i, j).g==colorkey.g && get_at(img, i, j).b==colorkey.b)){
                    if (i-1>=0){
                        if (get_at(img, i-1, j).r==colorkey.r && get_at(img, i-1, j).g==colorkey.g && get_at(img, i-1, j).b==colorkey.b){
                            on_border = true;
                        }
                    }
                    else{
                        if (!(get_at(img, i, j).r==colorkey.r && get_at(img, i, j).g==colorkey.g && get_at(img, i, j).b==colorkey.b)){
                            on_border = true;
                        }
                    }
                    if (j-1>=0){
                        if (get_at(img, i, j-1).r==colorkey.r && get_at(img, i, j-1).g==colorkey.g && get_at(img, i, j-1).b==colorkey.b){
                            on_border = true;
                        }
                    }
                    else{
                        if (!(get_at(img, i, j).r==colorkey.r && get_at(img, i, j).g==colorkey.g && get_at(img, i, j).b==colorkey.b)){
                            on_border = true;
                        }
                    }
                    if (i+1<img->w){
                        if (get_at(img, i+1, j).r==colorkey.r && get_at(img, i+1, j).g==colorkey.g && get_at(img, i+1, j).b==colorkey.b){
                            on_border = true;
                        }
                    }
                    else{
                        if (!(get_at(img, i, j).r==colorkey.r && get_at(img, i, j).g==colorkey.g && get_at(img, i, j).b==colorkey.b)){
                            on_border = true;
                        }
                    }
                    if (j+1<img->h){
                        if (get_at(img, i, j+1).r==colorkey.r && get_at(img, i, j+1).g==colorkey.g && get_at(img, i, j+1).b==colorkey.b){
                            on_border = true;
                        }
                    }
                    else{
                        if (!(get_at(img, i, j).r==colorkey.r && get_at(img, i, j).g==colorkey.g && get_at(img, i, j).b==colorkey.b)){
                            on_border = true;
                        }
                    }
                }
                if (on_border){
                    vector<int> pos = {i, j};
                    outline.push_back(pos);
                }
            }
        }
        position[0] = pos[0];
        position[1] = pos[1];
        for (int l = 0; l<outline.size(); l=l+1){
            rec.x = pos[0]+outline[l][0]*scale;
            rec.y = pos[1]+outline[l][1]*scale;
            outline_rects.push_back(rec);
        }
        //cout << outline_rects.size() << endl;
    }  
    void update(){ 
        image.blit(position);
        for (int l = 0; l<outline_rects.size(); l=l+1){
            SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
            SDL_RenderFillRect(renderer, &outline_rects[l]);
            SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        }
    }
    
};
class AnimatedSprite{
    public:
    vector<Sprite> frames;
    Surf_Spritesheet image;
    int position[2];
    int frame[2] = {0, 0};
    int delay = 0;
    int length;
    Uint32 colkey;
    int framechange;
    void init(SDL_Surface *img, int pos[2], int size_[2], int spacing=1,double scale = 1, SDL_Color colorkey = {255, 255, 255}, int framechange_=8){
        colkey = (255<<24) + (int(colorkey.b)<<16) + (int(colorkey.g)<<8) + int(colorkey.r);
        image.init(img, size_, colkey, spacing);
        for (int i = 0; i < size_[0]; i=i+1){
            Sprite sprite;
            frame[0] = i;
            sprite.init(image.get(frame), pos, scale, colorkey);
            frames.push_back(sprite);
        }    
        length = size_[0]-1;
        framechange = framechange_;
    } 
    void update(){ 
        delay += 1;
        if (delay%framechange==0){
            frame[0]+=1;
            if (frame[0]>length){
                frame[0]=0;
            }
        }
        frames[frame[0]].update();
    }
    
};
class SpriteStack{
    public:
    vector<SDL_Surface*> layers;
    float spread = 0;
    SDL_FRect dstrect;
    SDL_Surface *surf;
    SDL_FPoint dst;
    SDL_Texture *tex;
    SDL_Texture *dst_tex;
    SDL_Point tex_size;
    vector<SDL_Texture*> tex_cache;
    void init(SDL_Surface *stack, int size[2], float spread_ = 1){
        spread = spread_;
        Surf_Spritesheet s;
        SDL_SetColorKey(stack, SDL_TRUE, white);
        s.init(stack, size);
        for(int i =0; i< s.sheet.size(); i++){
            layers.push_back(s.sheet[s.sheet.size()-1-i][0]);
        }
        dst_tex = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, layers[0]->w*2+60, layers[0]->h*2+60);
        tex_size = getsize(dst_tex);
        dstrect.w = layers[0]->w*2;
        dstrect.h = layers[0]->h*2;
        dstrect.x = layers[0]->w;
        dstrect.y = layers[0]->h;
        for (int ang = 0; ang < 361; ang++){
            
            tex_cache.push_back(SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, layers[0]->w*2+60, layers[0]->h*2+60));
            SDL_SetTextureBlendMode(tex_cache[ang], SDL_BLENDMODE_BLEND);
            SDL_SetRenderTarget(renderer, tex_cache[ang]);
            SDL_RenderClear(renderer);
            for (int i = 0; i < layers.size(); i++){
                SDL_FreeSurface(surf);
                surf = rotate_surface(layers[i], ang);
                SDL_SetColorKey(surf, SDL_TRUE, black);
                dstrect.x = (float)tex_size.x/2-surf->w/2;
                dstrect.y = (float)tex_size.y/2-surf->h/2-(i*spread);
                dstrect.w = surf->w;
                dstrect.h = surf->h;
                SDL_DestroyTexture(tex);
                tex = SDL_CreateTextureFromSurface(renderer, surf);
                SDL_RenderCopyF(renderer, tex, NULL, &dstrect);
                
            }
            SDL_SetRenderTarget(renderer, NULL);
            
        }
    }
    void render(SDL_Point p, int angle=0, double scale=1){
        dstrect.x = p.x;
        dstrect.y = p.y;
        dstrect.w = layers[0]->w*scale;
        dstrect.h = layers[0]->h*scale;
        if (angle<0) SDL_RenderCopyF(renderer, tex_cache[360+angle%360], NULL, &dstrect);
        if (angle>360) SDL_RenderCopyF(renderer, tex_cache[angle%360], NULL, &dstrect);
        if (angle>=0 && angle<=360) SDL_RenderCopyF(renderer, tex_cache[angle], NULL, &dstrect);
    }
};
template < typename ret, typename T, typename... Rest > using fn = std::function< ret(T, Rest...) >;
template < typename ret, typename T, typename... Rest > ret wrapper(fn< ret, T, Rest... > f, T t, Rest... rest)
{
  return f(t, rest...);
}

template < typename ret, typename T, typename... Rest > ret wrapper(fn< ret, T &, Rest &... > f, T &t, Rest &...rest)
{
  return f(t, rest...);
}
int test(int in){
    cout << "Button works!" << endl;
    return 1;
}
auto test_func = fn<int, int>(test);
#pragma once
#include "classes.hpp"
namespace object_variables{
    Image cursor_img;
};
using namespace object_variables;

/*  

SDL2_rotozoom.c: rotozoomer, zoomer and shrinker for 32bit or 8bit surfaces

Copyright (C) 2012  Andreas Schiffler

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.

Andreas Schiffler -- aschiffler at ferzkopp dot net

*/

#ifdef WIN32
#include "windows.h"
#endif

#include "stdlib.h"
#include "string.h"

#include "SDL2_rotozoom.h"

/* ---- Internally used structures */

/*!
\brief A 32 bit RGBA pixel.
*/
typedef struct tColorRGBA {
	Uint8 r;
	Uint8 g;
	Uint8 b;
	Uint8 a;
} tColorRGBA;

/*!
\brief A 8bit Y/palette pixel.
*/
typedef struct tColorY {
	Uint8 y;
} tColorY;

/*! 
\brief Returns maximum of two numbers a and b.
*/
#define MAX(a,b)    (((a) > (b)) ? (a) : (b))

/*! 
\brief Number of guard rows added to destination surfaces.

This is a simple but effective workaround for observed issues.
These rows allocate extra memory and are then hidden from the surface.
Rows are added to the end of destination surfaces when they are allocated. 
This catches any potential overflows which seem to happen with 
just the right src image dimensions and scale/rotation and can lead
to a situation where the program can segfault.
*/
#define GUARD_ROWS (2)

/*!
\brief Lower limit of absolute zoom factor or rotation degrees.
*/
#define VALUE_LIMIT	0.001

/*!
\brief Returns colorkey info for a surface
*/
Uint32 _colorkey(SDL_Surface *src)
{
	Uint32 key = 0; 
	SDL_GetColorKey(src, &key);
	return key;
}


/*! 
\brief Internal 32 bit integer-factor averaging Shrinker.

Shrinks 32 bit RGBA/ABGR 'src' surface to 'dst' surface.
Averages color and alpha values values of src pixels to calculate dst pixels.
Assumes src and dst surfaces are of 32 bit depth.
Assumes dst surface was allocated with the correct dimensions.

\param src The surface to shrink (input).
\param dst The shrunken surface (output).
\param factorx The horizontal shrinking ratio.
\param factory The vertical shrinking ratio.

\return 0 for success or -1 for error.
*/
int _shrinkSurfaceRGBA(SDL_Surface * src, SDL_Surface * dst, int factorx, int factory)
{
	int x, y, dx, dy, dgap, ra, ga, ba, aa;
	int n_average;
	tColorRGBA *sp, *osp, *oosp;
	tColorRGBA *dp;

	/*
	* Averaging integer shrink
	*/

	/* Precalculate division factor */
	n_average = factorx*factory;

	/*
	* Scan destination
	*/
	sp = (tColorRGBA *) src->pixels;
	
	dp = (tColorRGBA *) dst->pixels;
	dgap = dst->pitch - dst->w * 4;

	for (y = 0; y < dst->h; y++) {

		osp=sp;
		for (x = 0; x < dst->w; x++) {

			/* Trace out source box and accumulate */
			oosp=sp;
			ra=ga=ba=aa=0;
			for (dy=0; dy < factory; dy++) {
				for (dx=0; dx < factorx; dx++) {
					ra += sp->r;
					ga += sp->g;
					ba += sp->b;
					aa += sp->a;

					sp++;
				} 
				/* src dx loop */
				sp = (tColorRGBA *)((Uint8*)sp + (src->pitch - 4*factorx)); // next y
			}
			/* src dy loop */

			/* next box-x */
			sp = (tColorRGBA *)((Uint8*)oosp + 4*factorx);

			/* Store result in destination */
			dp->r = ra/n_average;
			dp->g = ga/n_average;
			dp->b = ba/n_average;
			dp->a = aa/n_average;

			/*
			* Advance destination pointer 
			*/
			dp++;
		} 
		/* dst x loop */

		/* next box-y */
		sp = (tColorRGBA *)((Uint8*)osp + src->pitch*factory);

		/*
		* Advance destination pointers 
		*/
		dp = (tColorRGBA *) ((Uint8 *) dp + dgap);
	} 
	/* dst y loop */

	return (0);
}

/*! 
\brief Internal 8 bit integer-factor averaging shrinker.

Shrinks 8bit Y 'src' surface to 'dst' surface.
Averages color (brightness) values values of src pixels to calculate dst pixels.
Assumes src and dst surfaces are of 8 bit depth.
Assumes dst surface was allocated with the correct dimensions.

\param src The surface to shrink (input).
\param dst The shrunken surface (output).
\param factorx The horizontal shrinking ratio.
\param factory The vertical shrinking ratio.

\return 0 for success or -1 for error.
*/
int _shrinkSurfaceY(SDL_Surface * src, SDL_Surface * dst, int factorx, int factory)
{
	int x, y, dx, dy, dgap, a;
	int n_average;
	Uint8 *sp, *osp, *oosp;
	Uint8 *dp;

	/*
	* Averaging integer shrink
	*/

	/* Precalculate division factor */
	n_average = factorx*factory;

	/*
	* Scan destination
	*/
	sp = (Uint8 *) src->pixels;

	dp = (Uint8 *) dst->pixels;
	dgap = dst->pitch - dst->w;

	for (y = 0; y < dst->h; y++) {    

		osp=sp;
		for (x = 0; x < dst->w; x++) {

			/* Trace out source box and accumulate */
			oosp=sp;
			a=0;
			for (dy=0; dy < factory; dy++) {
				for (dx=0; dx < factorx; dx++) {
					a += (*sp);
					/* next x */           
					sp++;
				} 
				/* end src dx loop */         
				/* next y */
				sp = (Uint8 *)((Uint8*)sp + (src->pitch - factorx)); 
			} 
			/* end src dy loop */

			/* next box-x */
			sp = (Uint8 *)((Uint8*)oosp + factorx);

			/* Store result in destination */
			*dp = a/n_average;

			/*
			* Advance destination pointer 
			*/
			dp++;
		} 
		/* end dst x loop */

		/* next box-y */
		sp = (Uint8 *)((Uint8*)osp + src->pitch*factory);

		/*
		* Advance destination pointers 
		*/
		dp = (Uint8 *)((Uint8 *)dp + dgap);
	} 
	/* end dst y loop */

	return (0);
}

/*! 
\brief Internal 32 bit Zoomer with optional anti-aliasing by bilinear interpolation.

Zooms 32 bit RGBA/ABGR 'src' surface to 'dst' surface.
Assumes src and dst surfaces are of 32 bit depth.
Assumes dst surface was allocated with the correct dimensions.

\param src The surface to zoom (input).
\param dst The zoomed surface (output).
\param flipx Flag indicating if the image should be horizontally flipped.
\param flipy Flag indicating if the image should be vertically flipped.
\param smooth Antialiasing flag; set to SMOOTHING_ON to enable.

\return 0 for success or -1 for error.
*/
int _zoomSurfaceRGBA(SDL_Surface * src, SDL_Surface * dst, int flipx, int flipy, int smooth)
{
	int x, y, sx, sy, ssx, ssy, *sax, *say, *csax, *csay, *salast, csx, csy, ex, ey, cx, cy, sstep, sstepx, sstepy;
	tColorRGBA *c00, *c01, *c10, *c11;
	tColorRGBA *sp, *csp, *dp;
	int spixelgap, spixelw, spixelh, dgap, t1, t2;

	/*
	* Allocate memory for row/column increments 
	*/
	if ((sax = (int *) malloc((dst->w + 1) * sizeof(Uint32))) == NULL) {
		return (-1);
	}
	if ((say = (int *) malloc((dst->h + 1) * sizeof(Uint32))) == NULL) {
		free(sax);
		return (-1);
	}

	/*
	* Precalculate row increments 
	*/
	spixelw = (src->w - 1);
	spixelh = (src->h - 1);
	if (smooth) {
		sx = (int) (65536.0 * (float) spixelw / (float) (dst->w - 1));
		sy = (int) (65536.0 * (float) spixelh / (float) (dst->h - 1));
	} else {
		sx = (int) (65536.0 * (float) (src->w) / (float) (dst->w));
		sy = (int) (65536.0 * (float) (src->h) / (float) (dst->h));
	}

	/* Maximum scaled source size */
	ssx = (src->w << 16) - 1;
	ssy = (src->h << 16) - 1;

	/* Precalculate horizontal row increments */
	csx = 0;
	csax = sax;
	for (x = 0; x <= dst->w; x++) {
		*csax = csx;
		csax++;
		csx += sx;

		/* Guard from overflows */
		if (csx > ssx) { 
			csx = ssx; 
		}
	}

	/* Precalculate vertical row increments */
	csy = 0;
	csay = say;
	for (y = 0; y <= dst->h; y++) {
		*csay = csy;
		csay++;
		csy += sy;

		/* Guard from overflows */
		if (csy > ssy) {
			csy = ssy;
		}
	}

	sp = (tColorRGBA *) src->pixels;
	dp = (tColorRGBA *) dst->pixels;
	dgap = dst->pitch - dst->w * 4;
	spixelgap = src->pitch/4;

	if (flipx) sp += spixelw;
	if (flipy) sp += (spixelgap * spixelh);

	/*
	* Switch between interpolating and non-interpolating code 
	*/
	if (smooth) {

		/*
		* Interpolating Zoom 
		*/
		csay = say;
		for (y = 0; y < dst->h; y++) {
			csp = sp;
			csax = sax;
			for (x = 0; x < dst->w; x++) {
				/*
				* Setup color source pointers 
				*/
				ex = (*csax & 0xffff);
				ey = (*csay & 0xffff);
				cx = (*csax >> 16);
				cy = (*csay >> 16);
				sstepx = cx < spixelw;
				sstepy = cy < spixelh;
				c00 = sp;
				c01 = sp;
				c10 = sp;
				if (sstepy) {
					if (flipy) {
						c10 -= spixelgap;
					} else {
						c10 += spixelgap;
					}
				}
				c11 = c10;
				if (sstepx) {
					if (flipx) {
						c01--;
						c11--;
					} else {
						c01++;
						c11++;
					}
				}

				/*
				* Draw and interpolate colors 
				*/
				t1 = ((((c01->r - c00->r) * ex) >> 16) + c00->r) & 0xff;
				t2 = ((((c11->r - c10->r) * ex) >> 16) + c10->r) & 0xff;
				dp->r = (((t2 - t1) * ey) >> 16) + t1;
				t1 = ((((c01->g - c00->g) * ex) >> 16) + c00->g) & 0xff;
				t2 = ((((c11->g - c10->g) * ex) >> 16) + c10->g) & 0xff;
				dp->g = (((t2 - t1) * ey) >> 16) + t1;
				t1 = ((((c01->b - c00->b) * ex) >> 16) + c00->b) & 0xff;
				t2 = ((((c11->b - c10->b) * ex) >> 16) + c10->b) & 0xff;
				dp->b = (((t2 - t1) * ey) >> 16) + t1;
				t1 = ((((c01->a - c00->a) * ex) >> 16) + c00->a) & 0xff;
				t2 = ((((c11->a - c10->a) * ex) >> 16) + c10->a) & 0xff;
				dp->a = (((t2 - t1) * ey) >> 16) + t1;				
				/*
				* Advance source pointer x
				*/
				salast = csax;
				csax++;				
				sstep = (*csax >> 16) - (*salast >> 16);
				if (flipx) {
					sp -= sstep;
				} else {
					sp += sstep;
				}

				/*
				* Advance destination pointer x
				*/
				dp++;
			}
			/*
			* Advance source pointer y
			*/
			salast = csay;
			csay++;
			sstep = (*csay >> 16) - (*salast >> 16);
			sstep *= spixelgap;
			if (flipy) { 
				sp = csp - sstep;
			} else {
				sp = csp + sstep;
			}

			/*
			* Advance destination pointer y
			*/
			dp = (tColorRGBA *) ((Uint8 *) dp + dgap);
		}
	} else {
		/*
		* Non-Interpolating Zoom 
		*/		
		csay = say;
		for (y = 0; y < dst->h; y++) {
			csp = sp;
			csax = sax;
			for (x = 0; x < dst->w; x++) {
				/*
				* Draw 
				*/
				*dp = *sp;

				/*
				* Advance source pointer x
				*/
				salast = csax;
				csax++;				
				sstep = (*csax >> 16) - (*salast >> 16);
				if (flipx) sstep = -sstep;
				sp += sstep;

				/*
				* Advance destination pointer x
				*/
				dp++;
			}
			/*
			* Advance source pointer y
			*/
			salast = csay;
			csay++;
			sstep = (*csay >> 16) - (*salast >> 16);
			sstep *= spixelgap;
			if (flipy) sstep = -sstep;			
			sp = csp + sstep;

			/*
			* Advance destination pointer y
			*/
			dp = (tColorRGBA *) ((Uint8 *) dp + dgap);
		}
	}

	/*
	* Remove temp arrays 
	*/
	free(sax);
	free(say);

	return (0);
}

/*! 

\brief Internal 8 bit Zoomer without smoothing.

Zooms 8bit palette/Y 'src' surface to 'dst' surface.
Assumes src and dst surfaces are of 8 bit depth.
Assumes dst surface was allocated with the correct dimensions.

\param src The surface to zoom (input).
\param dst The zoomed surface (output).
\param flipx Flag indicating if the image should be horizontally flipped.
\param flipy Flag indicating if the image should be vertically flipped.

\return 0 for success or -1 for error.
*/
int _zoomSurfaceY(SDL_Surface * src, SDL_Surface * dst, int flipx, int flipy)
{
	int x, y;
	Uint32 *sax, *say, *csax, *csay;
	int csx, csy;
	Uint8 *sp, *dp, *csp;
	int dgap;

	/*
	* Allocate memory for row increments 
	*/
	if ((sax = (Uint32 *) malloc((dst->w + 1) * sizeof(Uint32))) == NULL) {
		return (-1);
	}
	if ((say = (Uint32 *) malloc((dst->h + 1) * sizeof(Uint32))) == NULL) {
		free(sax);
		return (-1);
	}

	/*
	* Pointer setup 
	*/
	sp = csp = (Uint8 *) src->pixels;
	dp = (Uint8 *) dst->pixels;
	dgap = dst->pitch - dst->w;

	if (flipx) csp += (src->w-1);
	if (flipy) csp  = ( (Uint8*)csp + src->pitch*(src->h-1) );

	/*
	* Precalculate row increments 
	*/
	csx = 0;
	csax = sax;
	for (x = 0; x < dst->w; x++) {
		csx += src->w;
		*csax = 0;
		while (csx >= dst->w) {
			csx -= dst->w;
			(*csax)++;
		}
		(*csax) = (*csax) * (flipx ? -1 : 1);
		csax++;
	}
	csy = 0;
	csay = say;
	for (y = 0; y < dst->h; y++) {
		csy += src->h;
		*csay = 0;
		while (csy >= dst->h) {
			csy -= dst->h;
			(*csay)++;
		}
		(*csay) = (*csay) * (flipy ? -1 : 1);
		csay++;
	}

	/*
	* Draw 
	*/
	csay = say;
	for (y = 0; y < dst->h; y++) {
		csax = sax;
		sp = csp;
		for (x = 0; x < dst->w; x++) {
			/*
			* Draw 
			*/
			*dp = *sp;
			/*
			* Advance source pointers 
			*/
			sp += (*csax);
			csax++;
			/*
			* Advance destination pointer 
			*/
			dp++;
		}
		/*
		* Advance source pointer (for row) 
		*/
		csp += ((*csay) * src->pitch);
		csay++;

		/*
		* Advance destination pointers 
		*/
		dp += dgap;
	}

	/*
	* Remove temp arrays 
	*/
	free(sax);
	free(say);

	return (0);
}

/*! 
\brief Internal 32 bit rotozoomer with optional anti-aliasing.

Rotates and zooms 32 bit RGBA/ABGR 'src' surface to 'dst' surface based on the control 
parameters by scanning the destination surface and applying optionally anti-aliasing
by bilinear interpolation.
Assumes src and dst surfaces are of 32 bit depth.
Assumes dst surface was allocated with the correct dimensions.

\param src Source surface.
\param dst Destination surface.
\param cx Horizontal center coordinate.
\param cy Vertical center coordinate.
\param isin Integer version of sine of angle.
\param icos Integer version of cosine of angle.
\param flipx Flag indicating horizontal mirroring should be applied.
\param flipy Flag indicating vertical mirroring should be applied.
\param smooth Flag indicating anti-aliasing should be used.
*/
void _transformSurfaceRGBA(SDL_Surface * src, SDL_Surface * dst, int cx, int cy, int isin, int icos, int flipx, int flipy, int smooth)
{
	int x, y, t1, t2, dx, dy, xd, yd, sdx, sdy, ax, ay, ex, ey, sw, sh;
	tColorRGBA c00, c01, c10, c11, cswap;
	tColorRGBA *pc, *sp;
	int gap;

	/*
	* Variable setup 
	*/
	xd = ((src->w - dst->w) << 15);
	yd = ((src->h - dst->h) << 15);
	ax = (cx << 16) - (icos * cx);
	ay = (cy << 16) - (isin * cx);
	sw = src->w - 1;
	sh = src->h - 1;
	pc = (tColorRGBA*) dst->pixels;
	gap = dst->pitch - dst->w * 4;

	/*
	* Switch between interpolating and non-interpolating code 
	*/
	if (smooth) {
		for (y = 0; y < dst->h; y++) {
			dy = cy - y;
			sdx = (ax + (isin * dy)) + xd;
			sdy = (ay - (icos * dy)) + yd;
			for (x = 0; x < dst->w; x++) {
				dx = (sdx >> 16);
				dy = (sdy >> 16);
				if (flipx) dx = sw - dx;
				if (flipy) dy = sh - dy;
				if ((dx > -1) && (dy > -1) && (dx < (src->w-1)) && (dy < (src->h-1))) {
					sp = (tColorRGBA *)src->pixels;;
					sp += ((src->pitch/4) * dy);
					sp += dx;
					c00 = *sp;
					sp += 1;
					c01 = *sp;
					sp += (src->pitch/4);
					c11 = *sp;
					sp -= 1;
					c10 = *sp;
					if (flipx) {
						cswap = c00; c00=c01; c01=cswap;
						cswap = c10; c10=c11; c11=cswap;
					}
					if (flipy) {
						cswap = c00; c00=c10; c10=cswap;
						cswap = c01; c01=c11; c11=cswap;
					}
					/*
					* Interpolate colors 
					*/
					ex = (sdx & 0xffff);
					ey = (sdy & 0xffff);
					t1 = ((((c01.r - c00.r) * ex) >> 16) + c00.r) & 0xff;
					t2 = ((((c11.r - c10.r) * ex) >> 16) + c10.r) & 0xff;
					pc->r = (((t2 - t1) * ey) >> 16) + t1;
					t1 = ((((c01.g - c00.g) * ex) >> 16) + c00.g) & 0xff;
					t2 = ((((c11.g - c10.g) * ex) >> 16) + c10.g) & 0xff;
					pc->g = (((t2 - t1) * ey) >> 16) + t1;
					t1 = ((((c01.b - c00.b) * ex) >> 16) + c00.b) & 0xff;
					t2 = ((((c11.b - c10.b) * ex) >> 16) + c10.b) & 0xff;
					pc->b = (((t2 - t1) * ey) >> 16) + t1;
					t1 = ((((c01.a - c00.a) * ex) >> 16) + c00.a) & 0xff;
					t2 = ((((c11.a - c10.a) * ex) >> 16) + c10.a) & 0xff;
					pc->a = (((t2 - t1) * ey) >> 16) + t1;
				}
				sdx += icos;
				sdy += isin;
				pc++;
			}
			pc = (tColorRGBA *) ((Uint8 *) pc + gap);
		}
	} else {
		for (y = 0; y < dst->h; y++) {
			dy = cy - y;
			sdx = (ax + (isin * dy)) + xd;
			sdy = (ay - (icos * dy)) + yd;
			for (x = 0; x < dst->w; x++) {
				dx = (short) (sdx >> 16);
				dy = (short) (sdy >> 16);
				if (flipx) dx = (src->w-1)-dx;
				if (flipy) dy = (src->h-1)-dy;
				if ((dx >= 0) && (dy >= 0) && (dx < src->w) && (dy < src->h)) {
					sp = (tColorRGBA *) ((Uint8 *) src->pixels + src->pitch * dy);
					sp += dx;
					*pc = *sp;
				}
				sdx += icos;
				sdy += isin;
				pc++;
			}
			pc = (tColorRGBA *) ((Uint8 *) pc + gap);
		}
	}
}

/*!

\brief Rotates and zooms 8 bit palette/Y 'src' surface to 'dst' surface without smoothing.

Rotates and zooms 8 bit RGBA/ABGR 'src' surface to 'dst' surface based on the control 
parameters by scanning the destination surface.
Assumes src and dst surfaces are of 8 bit depth.
Assumes dst surface was allocated with the correct dimensions.

\param src Source surface.
\param dst Destination surface.
\param cx Horizontal center coordinate.
\param cy Vertical center coordinate.
\param isin Integer version of sine of angle.
\param icos Integer version of cosine of angle.
\param flipx Flag indicating horizontal mirroring should be applied.
\param flipy Flag indicating vertical mirroring should be applied.
*/
void transformSurfaceY(SDL_Surface * src, SDL_Surface * dst, int cx, int cy, int isin, int icos, int flipx, int flipy)
{
	int x, y, dx, dy, xd, yd, sdx, sdy, ax, ay;
	tColorY *pc, *sp;
	int gap;

	/*
	* Variable setup 
	*/
	xd = ((src->w - dst->w) << 15);
	yd = ((src->h - dst->h) << 15);
	ax = (cx << 16) - (icos * cx);
	ay = (cy << 16) - (isin * cx);
	pc = (tColorY*) dst->pixels;
	gap = dst->pitch - dst->w;
	/*
	* Clear surface to colorkey 
	*/ 	
	memset(pc, (int)(_colorkey(src) & 0xff), dst->pitch * dst->h);
	/*
	* Iterate through destination surface 
	*/
	for (y = 0; y < dst->h; y++) {
		dy = cy - y;
		sdx = (ax + (isin * dy)) + xd;
		sdy = (ay - (icos * dy)) + yd;
		for (x = 0; x < dst->w; x++) {
			dx = (short) (sdx >> 16);
			dy = (short) (sdy >> 16);
			if (flipx) dx = (src->w-1)-dx;
			if (flipy) dy = (src->h-1)-dy;
			if ((dx >= 0) && (dy >= 0) && (dx < src->w) && (dy < src->h)) {
				sp = (tColorY *) (src->pixels);
				sp += (src->pitch * dy + dx);
				*pc = *sp;
			}
			sdx += icos;
			sdy += isin;
			pc++;
		}
		pc += gap;
	}
}

/*!
\brief Rotates a 8/16/24/32 bit surface in increments of 90 degrees.

Specialized 90 degree rotator which rotates a 'src' surface in 90 degree 
increments clockwise returning a new surface. Faster than rotozoomer since
no scanning or interpolation takes place. Input surface must be 8/16/24/32 bit.
(code contributed by J. Schiller, improved by C. Allport and A. Schiffler)

\param src Source surface to rotate.
\param numClockwiseTurns Number of clockwise 90 degree turns to apply to the source.

\returns The new, rotated surface; or NULL for surfaces with incorrect input format.
*/
SDL_Surface* rotateSurface90Degrees(SDL_Surface* src, int numClockwiseTurns) 
{
	int row, col, newWidth, newHeight;
	int bpp, bpr;
	SDL_Surface* dst;
	Uint8* srcBuf;
	Uint8* dstBuf;
	int normalizedClockwiseTurns;

	/* Has to be a valid surface pointer and be a Nbit surface where n is divisible by 8 */
	if (!src || 
	    !src->format) {
		SDL_SetError("NULL source surface or source surface format");
	    return NULL; 
	}

	if ((src->format->BitsPerPixel % 8) != 0) {
		SDL_SetError("Invalid source surface bit depth");
	    return NULL; 
	}

	/* normalize numClockwiseTurns */
	normalizedClockwiseTurns = (numClockwiseTurns % 4);
	if (normalizedClockwiseTurns < 0) {
		normalizedClockwiseTurns += 4;
	}

	/* If turns are even, our new width/height will be the same as the source surface */
	if (normalizedClockwiseTurns % 2) {
		newWidth = src->h;
		newHeight = src->w;
	} else {
		newWidth = src->w;
		newHeight = src->h;
	}

	dst = SDL_CreateRGBSurface( src->flags, newWidth, newHeight, src->format->BitsPerPixel,
		src->format->Rmask,
		src->format->Gmask, 
		src->format->Bmask, 
		src->format->Amask);
	if(!dst) {
		SDL_SetError("Could not create destination surface"); 
		return NULL;
	}

	if (SDL_MUSTLOCK(src)) {
		SDL_LockSurface(src);
	}
	if (SDL_MUSTLOCK(dst)) {
		SDL_LockSurface(dst);
	}

	/* Calculate byte-per-pixel */
	bpp = src->format->BitsPerPixel / 8;

	switch(normalizedClockwiseTurns) {
	case 0: /* Make a copy of the surface */
		{
			/* Unfortunately SDL_BlitSurface cannot be used to make a copy of the surface
			since it does not preserve alpha. */

			if (src->pitch == dst->pitch) {
				/* If the pitch is the same for both surfaces, the memory can be copied all at once. */
				memcpy(dst->pixels, src->pixels, (src->h * src->pitch));
			}
			else
			{
				/* If the pitch differs, copy each row separately */
				srcBuf = (Uint8*)(src->pixels);
				dstBuf = (Uint8*)(dst->pixels);
				bpr = src->w * bpp;
				for (row = 0; row < src->h; row++) {
					memcpy(dstBuf, srcBuf, bpr);
					srcBuf += src->pitch;
					dstBuf += dst->pitch;
				}
			}
		}
		break;

		/* rotate clockwise */
	case 1: /* rotated 90 degrees clockwise */
		{
			for (row = 0; row < src->h; ++row) {
				srcBuf = (Uint8*)(src->pixels) + (row * src->pitch);
				dstBuf = (Uint8*)(dst->pixels) + (dst->w - row - 1) * bpp;
				for (col = 0; col < src->w; ++col) {
					memcpy (dstBuf, srcBuf, bpp);
					srcBuf += bpp;
					dstBuf += dst->pitch;
				} 
			} 
		}
		break;

	case 2: /* rotated 180 degrees clockwise */
		{
			for (row = 0; row < src->h; ++row) {
				srcBuf = (Uint8*)(src->pixels) + (row * src->pitch);
				dstBuf = (Uint8*)(dst->pixels) + ((dst->h - row - 1) * dst->pitch) + (dst->w - 1) * bpp;
				for (col = 0; col < src->w; ++col) {
					memcpy (dstBuf, srcBuf, bpp);
					srcBuf += bpp;
					dstBuf -= bpp;
				} 
			} 
		}
		break;

	case 3: /* rotated 270 degrees clockwise */
		{
			for (row = 0; row < src->h; ++row) {
				srcBuf = (Uint8*)(src->pixels) + (row * src->pitch);
				dstBuf = (Uint8*)(dst->pixels) + (row * bpp) + (dst->h * dst->pitch);
				for (col = 0; col < src->w; ++col) {
					memcpy (dstBuf, srcBuf, bpp);
					srcBuf += bpp;
					dstBuf -= dst->pitch;
				} 
			} 
		}
		break;
	} 
	/* end switch */

	if (SDL_MUSTLOCK(src)) {
		SDL_UnlockSurface(src);
	}
	if (SDL_MUSTLOCK(dst)) {
		SDL_UnlockSurface(dst);
	}

	return dst;
}


/*!
\brief Internal target surface sizing function for rotozooms with trig result return. 

\param width The source surface width.
\param height The source surface height.
\param angle The angle to rotate in degrees.
\param zoomx The horizontal scaling factor.
\param zoomy The vertical scaling factor.
\param dstwidth The calculated width of the destination surface.
\param dstheight The calculated height of the destination surface.
\param canglezoom The sine of the angle adjusted by the zoom factor.
\param sanglezoom The cosine of the angle adjusted by the zoom factor.

*/
void _rotozoomSurfaceSizeTrig(int width, int height, double angle, double zoomx, double zoomy, 
	int *dstwidth, int *dstheight, 
	double *canglezoom, double *sanglezoom)
{
	double x, y, cx, cy, sx, sy;
	double radangle;
	int dstwidthhalf, dstheighthalf;

	/*
	* Determine destination width and height by rotating a centered source box 
	*/
	radangle = angle * (M_PI / 180.0);
	*sanglezoom = sin(radangle);
	*canglezoom = cos(radangle);
	*sanglezoom *= zoomx;
	*canglezoom *= zoomx;
	x = (double)(width / 2);
	y = (double)(height / 2);
	cx = *canglezoom * x;
	cy = *canglezoom * y;
	sx = *sanglezoom * x;
	sy = *sanglezoom * y;

	dstwidthhalf = MAX((int)
		ceil(MAX(MAX(MAX(fabs(cx + sy), fabs(cx - sy)), fabs(-cx + sy)), fabs(-cx - sy))), 1);
	dstheighthalf = MAX((int)
		ceil(MAX(MAX(MAX(fabs(sx + cy), fabs(sx - cy)), fabs(-sx + cy)), fabs(-sx - cy))), 1);
	*dstwidth = 2 * dstwidthhalf;
	*dstheight = 2 * dstheighthalf;
}

/*! 
\brief Returns the size of the resulting target surface for a rotozoomSurfaceXY() call. 

\param width The source surface width.
\param height The source surface height.
\param angle The angle to rotate in degrees.
\param zoomx The horizontal scaling factor.
\param zoomy The vertical scaling factor.
\param dstwidth The calculated width of the rotozoomed destination surface.
\param dstheight The calculated height of the rotozoomed destination surface.
*/
void rotozoomSurfaceSizeXY(int width, int height, double angle, double zoomx, double zoomy, int *dstwidth, int *dstheight)
{
	double dummy_sanglezoom, dummy_canglezoom;

	_rotozoomSurfaceSizeTrig(width, height, angle, zoomx, zoomy, dstwidth, dstheight, &dummy_sanglezoom, &dummy_canglezoom);
}

/*! 
\brief Returns the size of the resulting target surface for a rotozoomSurface() call. 

\param width The source surface width.
\param height The source surface height.
\param angle The angle to rotate in degrees.
\param zoom The scaling factor.
\param dstwidth The calculated width of the rotozoomed destination surface.
\param dstheight The calculated height of the rotozoomed destination surface.
*/
void rotozoomSurfaceSize(int width, int height, double angle, double zoom, int *dstwidth, int *dstheight)
{
	double dummy_sanglezoom, dummy_canglezoom;

	_rotozoomSurfaceSizeTrig(width, height, angle, zoom, zoom, dstwidth, dstheight, &dummy_sanglezoom, &dummy_canglezoom);
}

/*!
\brief Rotates and zooms a surface and optional anti-aliasing. 

Rotates and zoomes a 32bit or 8bit 'src' surface to newly created 'dst' surface.
'angle' is the rotation in degrees and 'zoom' a scaling factor. If 'smooth' is set
then the destination 32bit surface is anti-aliased. If the surface is not 8bit
or 32bit RGBA/ABGR it will be converted into a 32bit RGBA format on the fly.

\param src The surface to rotozoom.
\param angle The angle to rotate in degrees.
\param zoom The scaling factor.
\param smooth Antialiasing flag; set to SMOOTHING_ON to enable.

\return The new rotozoomed surface.
*/
SDL_Surface *rotozoomSurface(SDL_Surface * src, double angle, double zoom, int smooth)
{
	return rotozoomSurfaceXY(src, angle, zoom, zoom, smooth);
}

/*!
\brief Rotates and zooms a surface with different horizontal and vertival scaling factors and optional anti-aliasing. 

Rotates and zooms a 32bit or 8bit 'src' surface to newly created 'dst' surface.
'angle' is the rotation in degrees, 'zoomx and 'zoomy' scaling factors. If 'smooth' is set
then the destination 32bit surface is anti-aliased. If the surface is not 8bit
or 32bit RGBA/ABGR it will be converted into a 32bit RGBA format on the fly.

\param src The surface to rotozoom.
\param angle The angle to rotate in degrees.
\param zoomx The horizontal scaling factor.
\param zoomy The vertical scaling factor.
\param smooth Antialiasing flag; set to SMOOTHING_ON to enable.

\return The new rotozoomed surface.
*/
SDL_Surface *rotozoomSurfaceXY(SDL_Surface * src, double angle, double zoomx, double zoomy, int smooth)
{
	SDL_Surface *rz_src;
	SDL_Surface *rz_dst;
	double zoominv;
	double sanglezoom, canglezoom, sanglezoominv, canglezoominv;
	int dstwidthhalf, dstwidth, dstheighthalf, dstheight;
	int is32bit;
	int i, src_converted;
	int flipx,flipy;

	/*
	* Sanity check 
	*/
	if (src == NULL) {
		return (NULL);
	}

	/*
	* Determine if source surface is 32bit or 8bit 
	*/
	is32bit = (src->format->BitsPerPixel == 32);
	if ((is32bit) || (src->format->BitsPerPixel == 8)) {
		/*
		* Use source surface 'as is' 
		*/
		rz_src = src;
		src_converted = 0;
	} else {
		/*
		* New source surface is 32bit with a defined RGBA ordering 
		*/
		rz_src =
			SDL_CreateRGBSurface(SDL_SWSURFACE, src->w, src->h, 32, 
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
			0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000
#else
			0xff000000,  0x00ff0000, 0x0000ff00, 0x000000ff
#endif
			);

		SDL_BlitSurface(src, NULL, rz_src, NULL);

		src_converted = 1;
		is32bit = 1;
	}

	/*
	* Sanity check zoom factor 
	*/
	flipx = (zoomx<0.0);
	if (flipx) zoomx=-zoomx;
	flipy = (zoomy<0.0);
	if (flipy) zoomy=-zoomy;
	if (zoomx < VALUE_LIMIT) zoomx = VALUE_LIMIT;
	if (zoomy < VALUE_LIMIT) zoomy = VALUE_LIMIT;
	zoominv = 65536.0 / (zoomx * zoomx);

	/*
	* Check if we have a rotozoom or just a zoom 
	*/
	if (fabs(angle) > VALUE_LIMIT) {

		/*
		* Angle!=0: full rotozoom 
		*/
		/*
		* ----------------------- 
		*/

		/* Determine target size */
		_rotozoomSurfaceSizeTrig(rz_src->w, rz_src->h, angle, zoomx, zoomy, &dstwidth, &dstheight, &canglezoom, &sanglezoom);

		/*
		* Calculate target factors from sin/cos and zoom 
		*/
		sanglezoominv = sanglezoom;
		canglezoominv = canglezoom;
		sanglezoominv *= zoominv;
		canglezoominv *= zoominv;

		/* Calculate half size */
		dstwidthhalf = dstwidth / 2;
		dstheighthalf = dstheight / 2;

		/*
		* Alloc space to completely contain the rotated surface 
		*/
		rz_dst = NULL;
		if (is32bit) {
			/*
			* Target surface is 32bit with source RGBA/ABGR ordering 
			*/
			rz_dst =
				SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 32,
				rz_src->format->Rmask, rz_src->format->Gmask,
				rz_src->format->Bmask, rz_src->format->Amask);
		} else {
			/*
			* Target surface is 8bit 
			*/
			rz_dst = SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 8, 0, 0, 0, 0);
		}

		/* Check target */
		if (rz_dst == NULL)
			return NULL;

		/* Adjust for guard rows */
		rz_dst->h = dstheight;

		/*
		* Lock source surface 
		*/
		if (SDL_MUSTLOCK(rz_src)) {
			SDL_LockSurface(rz_src);
		}

		/*
		* Check which kind of surface we have 
		*/
		if (is32bit) {
			/*
			* Call the 32bit transformation routine to do the rotation (using alpha) 
			*/
			_transformSurfaceRGBA(rz_src, rz_dst, dstwidthhalf, dstheighthalf,
				(int) (sanglezoominv), (int) (canglezoominv), 
				flipx, flipy,
				smooth);
		} else {
			/*
			* Copy palette and colorkey info 
			*/
			for (i = 0; i < rz_src->format->palette->ncolors; i++) {
				rz_dst->format->palette->colors[i] = rz_src->format->palette->colors[i];
			}
			rz_dst->format->palette->ncolors = rz_src->format->palette->ncolors;
			/*
			* Call the 8bit transformation routine to do the rotation 
			*/
			transformSurfaceY(rz_src, rz_dst, dstwidthhalf, dstheighthalf,
				(int) (sanglezoominv), (int) (canglezoominv),
				flipx, flipy);
		}
		/*
		* Unlock source surface 
		*/
		if (SDL_MUSTLOCK(rz_src)) {
			SDL_UnlockSurface(rz_src);
		}

	} else {

		/*
		* Angle=0: Just a zoom 
		*/
		/*
		* -------------------- 
		*/

		/*
		* Calculate target size
		*/
		zoomSurfaceSize(rz_src->w, rz_src->h, zoomx, zoomy, &dstwidth, &dstheight);

		/*
		* Alloc space to completely contain the zoomed surface 
		*/
		rz_dst = NULL;
		if (is32bit) {
			/*
			* Target surface is 32bit with source RGBA/ABGR ordering 
			*/
			rz_dst =
				SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 32,
				rz_src->format->Rmask, rz_src->format->Gmask,
				rz_src->format->Bmask, rz_src->format->Amask);
		} else {
			/*
			* Target surface is 8bit 
			*/
			rz_dst = SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 8, 0, 0, 0, 0);
		}

		/* Check target */
		if (rz_dst == NULL)
			return NULL;

		/* Adjust for guard rows */
		rz_dst->h = dstheight;

		/*
		* Lock source surface 
		*/
		if (SDL_MUSTLOCK(rz_src)) {
			SDL_LockSurface(rz_src);
		}

		/*
		* Check which kind of surface we have 
		*/
		if (is32bit) {
			/*
			* Call the 32bit transformation routine to do the zooming (using alpha) 
			*/
			_zoomSurfaceRGBA(rz_src, rz_dst, flipx, flipy, smooth);

		} else {
			/*
			* Copy palette and colorkey info 
			*/
			for (i = 0; i < rz_src->format->palette->ncolors; i++) {
				rz_dst->format->palette->colors[i] = rz_src->format->palette->colors[i];
			}
			rz_dst->format->palette->ncolors = rz_src->format->palette->ncolors;

			/*
			* Call the 8bit transformation routine to do the zooming 
			*/
			_zoomSurfaceY(rz_src, rz_dst, flipx, flipy);
		}

		/*
		* Unlock source surface 
		*/
		if (SDL_MUSTLOCK(rz_src)) {
			SDL_UnlockSurface(rz_src);
		}
	}

	/*
	* Cleanup temp surface 
	*/
	if (src_converted) {
		SDL_FreeSurface(rz_src);
	}

	/*
	* Return destination surface 
	*/
	return (rz_dst);
}

/*!
\brief Calculates the size of the target surface for a zoomSurface() call.

The minimum size of the target surface is 1. The input factors can be positive or negative.

\param width The width of the source surface to zoom.
\param height The height of the source surface to zoom.
\param zoomx The horizontal zoom factor.
\param zoomy The vertical zoom factor.
\param dstwidth Pointer to an integer to store the calculated width of the zoomed target surface.
\param dstheight Pointer to an integer to store the calculated height of the zoomed target surface.
*/
void zoomSurfaceSize(int width, int height, double zoomx, double zoomy, int *dstwidth, int *dstheight)
{
	/*
	* Make zoom factors positive 
	*/
	int flipx, flipy;
	flipx = (zoomx<0.0);
	if (flipx) zoomx = -zoomx;
	flipy = (zoomy<0.0);
	if (flipy) zoomy = -zoomy;

	/*
	* Sanity check zoom factors 
	*/
	if (zoomx < VALUE_LIMIT) {
		zoomx = VALUE_LIMIT;
	}
	if (zoomy < VALUE_LIMIT) {
		zoomy = VALUE_LIMIT;
	}

	/*
	* Calculate target size 
	*/
	*dstwidth = (int) floor(((double) width * zoomx) + 0.5);
	*dstheight = (int) floor(((double) height * zoomy) + 0.5);
	if (*dstwidth < 1) {
		*dstwidth = 1;
	}
	if (*dstheight < 1) {
		*dstheight = 1;
	}
}

/*! 
\brief Zoom a surface by independent horizontal and vertical factors with optional smoothing.

Zooms a 32bit or 8bit 'src' surface to newly created 'dst' surface.
'zoomx' and 'zoomy' are scaling factors for width and height. If 'smooth' is on
then the destination 32bit surface is anti-aliased. If the surface is not 8bit
or 32bit RGBA/ABGR it will be converted into a 32bit RGBA format on the fly.
If zoom factors are negative, the image is flipped on the axes.

\param src The surface to zoom.
\param zoomx The horizontal zoom factor.
\param zoomy The vertical zoom factor.
\param smooth Antialiasing flag; set to SMOOTHING_ON to enable.

\return The new, zoomed surface.
*/
SDL_Surface *zoomSurface(SDL_Surface * src, double zoomx, double zoomy, int smooth)
{
	SDL_Surface *rz_src;
	SDL_Surface *rz_dst;
	int dstwidth, dstheight;
	int is32bit;
	int i, src_converted;
	int flipx, flipy;

	/*
	* Sanity check 
	*/
	if (src == NULL)
		return (NULL);

	/*
	* Determine if source surface is 32bit or 8bit 
	*/
	is32bit = (src->format->BitsPerPixel == 32);
	if ((is32bit) || (src->format->BitsPerPixel == 8)) {
		/*
		* Use source surface 'as is' 
		*/
		rz_src = src;
		src_converted = 0;
	} else {
		/*
		* New source surface is 32bit with a defined RGBA ordering 
		*/
		rz_src =
			SDL_CreateRGBSurface(SDL_SWSURFACE, src->w, src->h, 32, 
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
			0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000
#else
			0xff000000,  0x00ff0000, 0x0000ff00, 0x000000ff
#endif
			);
		if (rz_src == NULL) {
			return NULL;
		}
		SDL_BlitSurface(src, NULL, rz_src, NULL);
		src_converted = 1;
		is32bit = 1;
	}

	flipx = (zoomx<0.0);
	if (flipx) zoomx = -zoomx;
	flipy = (zoomy<0.0);
	if (flipy) zoomy = -zoomy;

	/* Get size if target */
	zoomSurfaceSize(rz_src->w, rz_src->h, zoomx, zoomy, &dstwidth, &dstheight);

	/*
	* Alloc space to completely contain the zoomed surface 
	*/
	rz_dst = NULL;
	if (is32bit) {
		/*
		* Target surface is 32bit with source RGBA/ABGR ordering 
		*/
		rz_dst =
			SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 32,
			rz_src->format->Rmask, rz_src->format->Gmask,
			rz_src->format->Bmask, rz_src->format->Amask);
	} else {
		/*
		* Target surface is 8bit 
		*/
		rz_dst = SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 8, 0, 0, 0, 0);
	}

	/* Check target */
	if (rz_dst == NULL) {
		/*
		* Cleanup temp surface 
		*/
		if (src_converted) {
			SDL_FreeSurface(rz_src);
		}		
		return NULL;
	}

	/* Adjust for guard rows */
	rz_dst->h = dstheight;

	/*
	* Lock source surface 
	*/
	if (SDL_MUSTLOCK(rz_src)) {
		SDL_LockSurface(rz_src);
	}

	/*
	* Check which kind of surface we have 
	*/
	if (is32bit) {
		/*
		* Call the 32bit transformation routine to do the zooming (using alpha) 
		*/
		_zoomSurfaceRGBA(rz_src, rz_dst, flipx, flipy, smooth);
	} else {
		/*
		* Copy palette and colorkey info 
		*/
		for (i = 0; i < rz_src->format->palette->ncolors; i++) {
			rz_dst->format->palette->colors[i] = rz_src->format->palette->colors[i];
		}
		rz_dst->format->palette->ncolors = rz_src->format->palette->ncolors;
		/*
		* Call the 8bit transformation routine to do the zooming 
		*/
		_zoomSurfaceY(rz_src, rz_dst, flipx, flipy);
	}
	/*
	* Unlock source surface 
	*/
	if (SDL_MUSTLOCK(rz_src)) {
		SDL_UnlockSurface(rz_src);
	}

	/*
	* Cleanup temp surface 
	*/
	if (src_converted) {
		SDL_FreeSurface(rz_src);
	}

	/*
	* Return destination surface 
	*/
	return (rz_dst);
}

/*! 
\brief Shrink a surface by an integer ratio using averaging.

Shrinks a 32bit or 8bit 'src' surface to a newly created 'dst' surface.
'factorx' and 'factory' are the shrinking ratios (i.e. 2=1/2 the size,
3=1/3 the size, etc.) The destination surface is antialiased by averaging
the source box RGBA or Y information. If the surface is not 8bit
or 32bit RGBA/ABGR it will be converted into a 32bit RGBA format on the fly.
The input surface is not modified. The output surface is newly allocated.

\param src The surface to shrink.
\param factorx The horizontal shrinking ratio.
\param factory The vertical shrinking ratio.

\return The new, shrunken surface.
*/
/*@null@*/ 
SDL_Surface *shrinkSurface(SDL_Surface *src, int factorx, int factory)
{
	int result;
	SDL_Surface *rz_src;
	SDL_Surface *rz_dst = NULL;
	int dstwidth, dstheight;
	int is32bit;
	int i, src_converted;
	int haveError = 0;

	/*
	* Sanity check 
	*/
	if (src == NULL) {
		return (NULL);
	}

	/*
	* Determine if source surface is 32bit or 8bit 
	*/
	is32bit = (src->format->BitsPerPixel == 32);
	if ((is32bit) || (src->format->BitsPerPixel == 8)) {
		/*
		* Use source surface 'as is' 
		*/
		rz_src = src;
		src_converted = 0;
	} else {
		/*
		* New source surface is 32bit with a defined RGBA ordering 
		*/
		rz_src = SDL_CreateRGBSurface(SDL_SWSURFACE, src->w, src->h, 32, 
#if SDL_BYTEORDER == SDL_LIL_ENDIAN
			0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000
#else
			0xff000000,  0x00ff0000, 0x0000ff00, 0x000000ff
#endif
			);
		if (rz_src==NULL) {
			haveError = 1;
			goto exitShrinkSurface;
		}

		SDL_BlitSurface(src, NULL, rz_src, NULL);
		src_converted = 1;
		is32bit = 1;
	}

	/*
	* Lock the surface 
	*/
	if (SDL_MUSTLOCK(rz_src)) {
		if (SDL_LockSurface(rz_src) < 0) {
			haveError = 1;
			goto exitShrinkSurface;
		}
	}

	/* Get size for target */
	dstwidth=rz_src->w/factorx;
	while (dstwidth*factorx>rz_src->w) { dstwidth--; }
	dstheight=rz_src->h/factory;
	while (dstheight*factory>rz_src->h) { dstheight--; }

	/*
	* Alloc space to completely contain the shrunken surface
	* (with added guard rows)
	*/
	if (is32bit==1) {
		/*
		* Target surface is 32bit with source RGBA/ABGR ordering 
		*/
		rz_dst =
			SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 32,
			rz_src->format->Rmask, rz_src->format->Gmask,
			rz_src->format->Bmask, rz_src->format->Amask);
	} else {
		/*
		* Target surface is 8bit 
		*/
		rz_dst = SDL_CreateRGBSurface(SDL_SWSURFACE, dstwidth, dstheight + GUARD_ROWS, 8, 0, 0, 0, 0);
	}

	/* Check target */
	if (rz_dst == NULL) {
		haveError = 1;
		goto exitShrinkSurface;
	}

	/* Adjust for guard rows */
	rz_dst->h = dstheight;

	/*
	* Check which kind of surface we have 
	*/
	if (is32bit==1) {
		/*
		* Call the 32bit transformation routine to do the shrinking (using alpha) 
		*/
		result = _shrinkSurfaceRGBA(rz_src, rz_dst, factorx, factory);		
		if ((result!=0) || (rz_dst==NULL)) {
			haveError = 1;
			goto exitShrinkSurface;
		}
	} else {
		/*
		* Copy palette and colorkey info 
		*/
		for (i = 0; i < rz_src->format->palette->ncolors; i++) {
			rz_dst->format->palette->colors[i] = rz_src->format->palette->colors[i];
		}
		rz_dst->format->palette->ncolors = rz_src->format->palette->ncolors;
		/*
		* Call the 8bit transformation routine to do the shrinking 
		*/
		result = _shrinkSurfaceY(rz_src, rz_dst, factorx, factory);
		if (result!=0) {
			haveError = 1;
			goto exitShrinkSurface;
		}
	}

exitShrinkSurface:
	if (rz_src!=NULL) {
		/*
		* Unlock source surface 
		*/
		if (SDL_MUSTLOCK(rz_src)) {
			SDL_UnlockSurface(rz_src);
		}

		/*
		* Cleanup temp surface 
		*/
		if (src_converted==1) {
			SDL_FreeSurface(rz_src);
		}
	}

	/* Check error state; maybe need to cleanup destination */
	if (haveError==1) {
		if (rz_dst!=NULL) {
			SDL_FreeSurface(rz_dst);
		}
		rz_dst=NULL;
	} 

	/*
	* Return destination surface 
	*/
	return (rz_dst);
}
/*  

SDL2_rotozoom.c: rotozoomer, zoomer and shrinker for 32bit or 8bit surfaces

Copyright (C) 2001-2012  Andreas Schiffler

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source
distribution.

Andreas Schiffler -- aschiffler at ferzkopp dot net

*/

#ifndef _SDL2_rotozoom_h
#define _SDL2_rotozoom_h

#include "math.h"

/* Set up for C function definitions, even when using C++ */
#ifdef __cplusplus
extern "C" {
#endif

#ifndef M_PI
#define M_PI	3.1415926535897932384626433832795
#endif

#include "SDL2/SDL.h"

	/* ---- Defines */

	/*!
	\brief Disable anti-aliasing (no smoothing).
	*/
#define SMOOTHING_OFF		0

	/*!
	\brief Enable anti-aliasing (smoothing).
	*/
#define SMOOTHING_ON		1

	/* ---- Function Prototypes */

#ifdef _MSC_VER
#  if defined(DLL_EXPORT) && !defined(LIBSDL2_GFX_DLL_IMPORT)
#    define SDL2_ROTOZOOM_SCOPE __declspec(dllexport)
#  else
#    ifdef LIBSDL2_GFX_DLL_IMPORT
#      define SDL2_ROTOZOOM_SCOPE __declspec(dllimport)
#    endif
#  endif
#endif
#ifndef SDL2_ROTOZOOM_SCOPE
#  define SDL2_ROTOZOOM_SCOPE extern
#endif

	/* 

	Rotozoom functions

	*/

	SDL2_ROTOZOOM_SCOPE SDL_Surface *rotozoomSurface(SDL_Surface * src, double angle, double zoom, int smooth);

	SDL2_ROTOZOOM_SCOPE SDL_Surface *rotozoomSurfaceXY
		(SDL_Surface * src, double angle, double zoomx, double zoomy, int smooth);


	SDL2_ROTOZOOM_SCOPE void rotozoomSurfaceSize(int width, int height, double angle, double zoom, int *dstwidth,
		int *dstheight);

	SDL2_ROTOZOOM_SCOPE void rotozoomSurfaceSizeXY
		(int width, int height, double angle, double zoomx, double zoomy, 
		int *dstwidth, int *dstheight);

	/* 

	Zooming functions

	*/

	SDL2_ROTOZOOM_SCOPE SDL_Surface *zoomSurface(SDL_Surface * src, double zoomx, double zoomy, int smooth);

	SDL2_ROTOZOOM_SCOPE void zoomSurfaceSize(int width, int height, double zoomx, double zoomy, int *dstwidth, int *dstheight);

	/* 

	Shrinking functions

	*/     

	SDL2_ROTOZOOM_SCOPE SDL_Surface *shrinkSurface(SDL_Surface * src, int factorx, int factory);

	/* 

	Specialized rotation functions

	*/

	SDL2_ROTOZOOM_SCOPE SDL_Surface* rotateSurface90Degrees(SDL_Surface* src, int numClockwiseTurns);

	/* Ends C function definitions when using C++ */
#ifdef __cplusplus
}
#endif

#endif				/* _SDL2_rotozoom_h */
/*
______  ___   _   _______ ________  __
| ___ \/ _ \ | \ | |  _  \  _  |  \/  | Random for modern C++
| |_/ / /_\ \|  \| | | | | | | | .  . |
|    /|  _  || . ` | | | | | | | |\/| | version 1.4.1
| |\ \| | | || |\  | |/ /\ \_/ / |  | |
\_| \_\_| |_/\_| \_/___/  \___/\_|  |_/ https://github.com/effolkronium/random

Licensed under the MIT License <http://opensource.org/licenses/MIT>.
Copyright (c) 2017-2023 effolkronium (Illia Polishchuk)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files( the "Software" ), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions :

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#ifndef EFFOLKRONIUM_RANDOM_HPP
#define EFFOLKRONIUM_RANDOM_HPP

#include <random>
#include <chrono> // timed seed
#include <type_traits>
#include <cassert>
#include <initializer_list>
#include <utility> // std::forward, std::declval
#include <algorithm> // std::shuffle, std::next, std::distance
#include <iterator> // std::begin, std::end, std::iterator_traits
#include <limits> // std::numeric_limits
#include <ostream>
#include <istream>

namespace effolkronium {

    namespace details {
        /// Key type for getting common type numbers or objects
        struct common{ }; 

        /// True if type T is applicable by a std::uniform_int_distribution
        template<typename T>
        struct is_uniform_int {
            static constexpr bool value =
                   std::is_same<T,              short>::value
                || std::is_same<T,                int>::value
                || std::is_same<T,               long>::value
                || std::is_same<T,          long long>::value
                || std::is_same<T,     unsigned short>::value
                || std::is_same<T,       unsigned int>::value
                || std::is_same<T,      unsigned long>::value
                || std::is_same<T, unsigned long long>::value;
        };

        /// True if type T is applicable by a std::uniform_real_distribution
        template<typename T>
        struct is_uniform_real {
            static constexpr bool value =
                   std::is_same<T,       float>::value
                || std::is_same<T,      double>::value
                || std::is_same<T, long double>::value;
        };

        /// True if type T is plain byte
        template<typename T>
        struct is_byte {
            static constexpr bool value =
                   std::is_same<T,   signed char>::value
                || std::is_same<T, unsigned char>::value;
        };

        /// True if type T is plain number type
        template<typename T>
        struct is_supported_number {
            static constexpr bool value =
                   is_byte        <T>::value
                || is_uniform_real<T>::value
                || is_uniform_int <T>::value;
        };

        /// True if type T is character type
        template<typename T>
        struct is_supported_character {
            static constexpr bool value =
                   std::is_same<T, char>::value
                || std::is_same<T, wchar_t>::value
                || std::is_same<T, char16_t>::value
                || std::is_same<T, char32_t>::value;
        };

        /// True if type T is iterator
        template<typename T>
        struct is_iterator {
        private:
            static char test( ... );

            template <typename U,
                typename = typename std::iterator_traits<U>::difference_type,
                typename = typename std::iterator_traits<U>::pointer,
                typename = typename std::iterator_traits<U>::reference,
                typename = typename std::iterator_traits<U>::value_type,
                typename = typename std::iterator_traits<U>::iterator_category
            > static long test( U&& );
        public:
            static constexpr bool value = std::is_same<
                decltype( test( std::declval<T>( ) ) ), long>::value;
        };

        template <typename T>
        class has_reserve
        {
        private:
            template <typename C>
            static char test(...);

            template <typename C>
            static long test(decltype(&C::reserve));
        public:
            static constexpr bool value = std::is_same<
                decltype(test<T>(0)), long>::value;
        };

        template <typename T>
        class has_insert
        {
        private:
            template <typename C>
            static char test(...);

            template <typename C>
            static long test(decltype(&C::insert));
        public:
            static constexpr bool value = std::is_same<
                decltype(test<T>(0)), long>::value;
        };

    } // namespace details

    /// Default seeder for 'random' classes
    struct seeder_default {
        /// return seed sequence
        std::seed_seq& operator() ( ) {
            // MinGW issue, std::random_device returns constant value
            // Use std::seed_seq with additional seed from C++ chrono
            return seed_seq;
        }
    private:
        std::seed_seq seed_seq{ {
                static_cast<std::uintmax_t>( std::random_device{ }( ) ),
                static_cast<std::uintmax_t>( std::chrono::steady_clock::now( )
                                             .time_since_epoch( ).count( ) ),
        } };
    };

    /**
    * \brief Base template class for random 
    *        with static API and static internal member storage
    * \note it is NOT thread safe but more efficient then 
    *                           basic_random_thread_local
    * \param Engine A random engine with interface like in the std::mt19937
    * \param Seeder A seeder type which return seed for internal engine 
    *                                             through operator()
    */
    template<
        typename Engine,
        typename Seeder = seeder_default,
        template<typename> class IntegerDist = std::uniform_int_distribution,
        template<typename> class RealDist = std::uniform_real_distribution,
        typename BoolDist = std::bernoulli_distribution
    >
    class basic_random_static {
    public:
        basic_random_static( ) = delete;

        /// Type of used random number engine
        using engine_type = Engine;

        /// Type of used random number seeder
        using seeder_type = Seeder;

        /// Type of used integer distribution
        template<typename T>
        using integer_dist_t = IntegerDist<T>;

        /// Type of used real distribution
        template<typename T>
        using real_dist_t = RealDist<T>;

        /// Type of used bool distribution
        using bool_dist_t = BoolDist;

        /// Key type for getting common type numbers or objects
        using common = details::common;

        /**
        * \return The minimum value
        * potentially generated by the random-number engine
        */
        static constexpr typename Engine::result_type (min)( ) {
            return (Engine::min)( );
        }

        /**
        * \return The maximum value
        * potentially generated by the random-number engine
        */
        static constexpr typename Engine::result_type (max)( ) {
            return (Engine::max)( );
        }

        /// Advances the internal state by z times
        static void discard( const unsigned long long z ) {
            engine_instance( ).discard( z );
        }

        /// Reseed by Seeder
        static void reseed( ) {
            Seeder seeder;
            seed( seeder( ) );
        }

        /**
        * \brief Reinitializes the internal state
        * of the random-number engine using new seed value
        * \param value The seed value to use 
        *        in the initialization of the internal state
        */
        static void seed( const typename Engine::result_type value =
                          Engine::default_seed ) {
            engine_instance( ).seed( value );
        }

        /**
        * \brief Reinitializes the internal state
        * of the random-number engine using new seed value
        * \param seq The seed sequence 
        *        to use in the initialization of the internal state
        */
        template<typename Sseq>
        static void seed( Sseq& seq ) {
            engine_instance( ).seed( seq );
        }

        /// return random number from engine in [min(), max()] range
        static typename Engine::result_type get( ) {
            return engine_instance( )( );
        }

        /**
        * \brief Compares internal pseudo-random number engine
        *        with 'other' pseudo-random number engine.
        *        Two engines are equal, if their internal states
        *        are equivalent, that is, if they would generate
        *        equivalent values for any number of calls of operator()
        * \param other The engine, with which the internal engine will be compared
        * \return true, if other and internal engine are equal
        */
        static bool is_equal( const Engine& other ) {
            return engine_instance( ) == other;
        }

        /**
        * \brief Serializes the internal state of the
        *        internal pseudo-random number engine as a sequence
        *        of decimal numbers separated by one or more spaces,
        *        and inserts it to the stream ost. The fill character
        *        and the formatting flags of the stream are
        *        ignored and unaffected.
        * \param ost The output stream to insert the data to
        */
        template<typename CharT, typename Traits>
        static void serialize( std::basic_ostream<CharT, Traits>& ost ) {
            ost << engine_instance( );
        }

        /**
        * \brief Restores the internal state of the
        *        internal pseudo-random number engine from
        *        the serialized representation, which
        *        was created by an earlier call to 'serialize'
        *        using a stream with the same imbued locale and
        *        the same CharT and Traits.
        *        If the input cannot be deserialized,
        *        internal engine is left unchanged and failbit is raised on ist
        * \param ost The input stream to extract the data from
        */
        template<typename CharT, typename Traits>
        static void deserialize( std::basic_istream<CharT, Traits>& ist ) {
            ist >> engine_instance( );
        }

        /**
        * \brief Generate a random integer number in a [from; to] range
        *        by std::uniform_int_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random integer number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        static typename std::enable_if<details::is_uniform_int<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            if( from < to ) // Allow range from higher to lower
                return IntegerDist<T>{ from, to }( engine_instance( ) );
            return IntegerDist<T>{ to, from }( engine_instance( ) );
        }

        /**
        * \brief Generate a random real number in a [from; to] range
        *        by std::uniform_real_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random real number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        static typename std::enable_if<details::is_uniform_real<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            if( from < to ) // Allow range from higher to lower
                return RealDist<T>{ from, to }( engine_instance( ) );
            return RealDist<T>{ to, from }( engine_instance( ) );
        }

        /**
        * \brief Generate a random byte number in a [from; to] range
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random byte number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        static typename std::enable_if<details::is_byte<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            // Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                short, unsigned short>::type;

            return static_cast<T>( get<short_t>( from, to ) );
        }

        /**
        * \brief Generate a random common_type number in a [from; to] range
        * \param Key The Key type for this version of 'get' method
        *        Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random common_type number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Allow implicit type conversion
        * \note Prevent implicit type conversion from singed to unsigned types
        *       Why? std::common_type<Unsigned, Signed> chooses unsigned value,
        *                 then Signed value will be converted to Unsigned value
        *                       which gives us a wrong range for random values.
        *                           https://stackoverflow.com/a/5416498/5734836
        */
        template<
            typename Key,
            typename A,
            typename B, 
            typename C = typename std::common_type<A, B>::type
        >
        static typename std::enable_if<
               std::is_same<Key, common>::value
            && details::is_supported_number<A>::value
            && details::is_supported_number<B>::value
            // Prevent implicit type conversion from singed to unsigned types
            && std::is_signed<A>::value != std::is_unsigned<B>::value
            , C>::type get( A from = (std::numeric_limits<A>::min)( ),
                            B to = (std::numeric_limits<B>::max)( ) ) {
            return get( static_cast<C>( from ), static_cast<C>( to ) );
        }

        /**
        * \brief Generate a random character in a [from; to] range
        *        by std::uniform_int_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random character in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        static typename std::enable_if<details::is_supported_character<T>::value
            , T>::type get(T from = (std::numeric_limits<T>::min)(),
                T to = (std::numeric_limits<T>::max)()) {
            if (from < to) // Allow range from higher to lower
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from), static_cast<std::int64_t>(to) }(engine_instance()));
            return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to), static_cast<std::int64_t>(from) }(engine_instance()));
        }

        /**
        * \brief Generate a bool value with specific probability
        *                         by std::bernoulli_distribution
        * \param probability The probability of generating true in [0; 1] range
        *        0 means always false, 1 means always true
        * \return 'true' with 'probability' probability ('false' otherwise)
        */
        template<typename T>
        static typename std::enable_if<std::is_same<T, bool>::value
            , bool>::type get( const double probability = 0.5 ) {
            assert( 0 <= probability && 1 >= probability ); // out of [0; 1] range
            return BoolDist{ probability }( engine_instance( ) );
        }

        /**
        * \brief Return random value from initilizer_list
        * \param init_list initilizer_list with values
        * \return Random value from initilizer_list
        * \note Should be 1 or more elements in initilizer_list
        * \note Warning! Elements in initilizer_list can't be moved:
        *               https://stackoverflow.com/a/8193157/5734836
        */
        template<typename T>
        static T get( std::initializer_list<T> init_list ) {
            assert( 0u != init_list.size( ) );
            return *get( init_list.begin( ), init_list.end( ) );
        }

        /**
        * \brief Return random iterator from iterator range
        * \param first, last - the range of elements
        * \return Random iterator from [first, last) range
        * \note If first == last, return last
        */
        template<typename InputIt>
        static typename std::enable_if<details::is_iterator<InputIt>::value
            , InputIt>::type get( InputIt first, InputIt last ) {
            const auto size = std::distance( first, last );
            if( 0 == size ) return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next( first, get<diff_t>( 0, size - 1 ) );
        }

        /**
        * \brief Return random iterator from Container
        * \param container The container with elements
        * \return Random iterator from container
        * \note If container is empty return std::end( container ) iterator
        */
        template<typename Container>
        static auto get( Container& container ) -> 
            typename std::enable_if<details::is_iterator<
                decltype(std::begin(container))>::value
                , decltype(std::begin(container))
            >::type {
            return get( std::begin( container ), std::end( container ) );
        }

        /**
        * \brief Return container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        * \note Container "reserve" method will be called before generation
        */
        template<template<typename...> class Container, typename A>
        static typename std::enable_if<
                details::has_reserve<Container<A>>::value
            , Container<A>>::type get(A from, A to, std::size_t size) {
            Container<A> container;

            container.reserve(size);
            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get(from, to));

            return container;
        }

        /**
        * \brief Return container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        * \note Container "reserve" method will be called before generation
        */
        template<
            template<typename...> class Container,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        static typename std::enable_if<
                   std::is_same<Key, common>::value
                && details::has_reserve<Container<A>>::value
            , Container<C>>::type get(A start, B end, std::size_t size) {
            Container<C> container;

            container.reserve(size);
            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get<common>(start, end));

            return container;
        }

        /**
        * \brief Return container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<template<typename...> class Container, typename A>
        static typename std::enable_if<
              !details::has_reserve<Container<A>>::value
            , Container<A>>::type get(A start, A end, std::size_t size) {
            Container<A> container;

            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get(start, end));

            return container;
        }

        /**
        * \brief Return container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<
            template<typename...> class Container,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        static typename std::enable_if<
                 std::is_same<Key, common>::value
              && !details::has_reserve<Container<C>>::value
            , Container<C>>::type get(A start, B end, std::size_t size) {
            Container<C> container;

            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get<common>(start, end));

            return container;
        }

        /**
        * \brief Return array-like container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param N The number of elements in resulting container
        * \return Container filled with random values
        */
        template<template<typename AA, std::size_t NN, typename...> class Container, std::size_t N, typename A>
        static typename std::enable_if<
               !details::has_insert<Container<A, N>>::value
            , Container<A, N>>::type get(A start, A end) {
            Container<A, N> container = {{ 0 }};

            for (std::size_t i = 0; i < N; ++i)
                container[i] = get(start, end);

            return container;
        }

        /**
        * \brief Return array-like container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<
            template<typename AA, std::size_t NN, typename...> class Container,
            std::size_t N,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        static typename std::enable_if<
                  std::is_same<Key, common>::value
               && !details::has_insert<Container<C, N>>::value
            , Container<C, N>>::type get(A start, B end) {
            Container<C, N> container = {{ 0 }};

            for (std::size_t i = 0; i < N; ++i)
                container[i] = get<common>(start, end);

            return container;
        }

        /**
        * \brief Return random pointer from built-in array
        * \param array The built-in array with elements
        * \return Pointer to random element in array
        */
        template<typename T, std::size_t N>
        static T* get( T( &array )[ N ] ) {
            return std::addressof( array[ get<std::size_t>( 0, N - 1 ) ] );
        }

        /**
        * \brief Return value from custom Dist distribution
        *        seeded by internal random engine
        * \param Dist The type of custom distribution with next concept:
        *        http://en.cppreference.com/w/cpp/concept/RandomNumberDistribution
        * \param args The arguments which will be forwarded to Dist constructor
        * \return Value from custom distribution
        */
        template<typename Dist, typename... Args>
        static typename Dist::result_type get( Args&&... args ) {
            return Dist{ std::forward<Args>( args )... }( engine_instance( ) );
        }

        /**
        * \brief Return value from custom 'dist' distribution
        *        seeded by internal random engine
        * \param dist The custom distribution with next concept:
        *        http://en.cppreference.com/w/cpp/concept/RandomNumberDistribution
        * \param args The arguments which will be forwarded to Dist constructor
        * \return Value from custom 'dist' distribution
        */
        template<typename Dist>
        static typename Dist::result_type get( Dist& dist ) {
            return dist( engine_instance( ) );
        }

        /**
        * \brief Reorders the elements in the given range [first, last)
        *        such that each possible permutation of those elements
        *        has equal probability of appearance.
        * \param first, last - the range of elements to shuffle randomly       
        */
        template<typename RandomIt>
        static void shuffle( RandomIt first, RandomIt last ) {
            std::shuffle( first, last, engine_instance( ) );
        }

        /**
        * \brief Reorders the elements in the given container
        *        such that each possible permutation of those elements
        *        has equal probability of appearance.
        * \param container - the container with elements to shuffle randomly
        */
        template<typename Container>
        static void shuffle( Container& container ) {
            shuffle( std::begin( container ), std::end( container ) );
        }

        /// return internal engine by copy
        static Engine get_engine( ) {
            return engine_instance( );
        }

        /// return internal engine by ref
        static Engine& engine() {
            return engine_instance();
        }
    private:
        /// get reference to the static engine instance
        static Engine& engine_instance( ) {
            static Engine engine{ Seeder{ }( ) };
            return engine;
        }
    };

    /**
    * \brief Base template class for random 
    *        with thread_local API and thread_local internal member storage
    * \note it IS thread safe but less efficient then 
    *                           basic_random_static
    * \param Engine A random engine with interface like in the std::mt19937
    * \param Seeder A seeder type which return seed for internal engine 
    *                                             through operator()
    */
    template<
        typename Engine,
        typename Seeder = seeder_default,
        template<typename> class IntegerDist = std::uniform_int_distribution,
        template<typename> class RealDist = std::uniform_real_distribution,
        typename BoolDist = std::bernoulli_distribution
    >
    class basic_random_thread_local {
    public:
        basic_random_thread_local( ) = delete;

        /// Type of used random number engine
        using engine_type = Engine;

        /// Type of used random number seeder
        using seeder_type = Seeder;

        /// Type of used integer distribution
        template<typename T>
        using integer_dist_t = IntegerDist<T>;

        /// Type of used real distribution
        template<typename T>
        using real_dist_t = RealDist<T>;

        /// Type of used bool distribution
        using bool_dist_t = BoolDist;

        /// Key type for getting common type numbers or objects
        using common = details::common;

        /**
        * \return The minimum value
        * potentially generated by the random-number engine
        */
        static constexpr typename Engine::result_type (min)( ) {
            return (Engine::min)( );
        }

        /**
        * \return The maximum value
        * potentially generated by the random-number engine
        */
        static constexpr typename Engine::result_type (max)( ) {
            return (Engine::max)( );
        }

        /// Advances the internal state by z times
        static void discard( const unsigned long long z ) {
            engine_instance( ).discard( z );
        }

        /// Reseed by Seeder
        static void reseed( ) {
            Seeder seeder;
            seed( seeder( ) );
        }

        /**
        * \brief Reinitializes the internal state
        * of the random-number engine using new seed value
        * \param value The seed value to use 
        *        in the initialization of the internal state
        */
        static void seed( const typename Engine::result_type value =
                          Engine::default_seed ) {
            engine_instance( ).seed( value );
        }

        /**
        * \brief Reinitializes the internal state
        * of the random-number engine using new seed value
        * \param seq The seed sequence 
        *        to use in the initialization of the internal state
        */
        template<typename Sseq>
        static void seed( Sseq& seq ) {
            engine_instance( ).seed( seq );
        }

        /// return random number from engine in [min(), max()] range
        static typename Engine::result_type get( ) {
            return engine_instance( )( );
        }

        /**
        * \brief Compares internal pseudo-random number engine
        *        with 'other' pseudo-random number engine.
        *        Two engines are equal, if their internal states
        *        are equivalent, that is, if they would generate
        *        equivalent values for any number of calls of operator()
        * \param other The engine, with which the internal engine will be compared
        * \return true, if other and internal engine are equal
        */
        static bool is_equal( const Engine& other ) {
            return engine_instance( ) == other;
        }

        /**
        * \brief Serializes the internal state of the
        *        internal pseudo-random number engine as a sequence
        *        of decimal numbers separated by one or more spaces,
        *        and inserts it to the stream ost. The fill character
        *        and the formatting flags of the stream are
        *        ignored and unaffected.
        * \param ost The output stream to insert the data to
        */
        template<typename CharT, typename Traits>
        static void serialize( std::basic_ostream<CharT, Traits>& ost ) {
            ost << engine_instance( );
        }

        /**
        * \brief Restores the internal state of the
        *        internal pseudo-random number engine from
        *        the serialized representation, which
        *        was created by an earlier call to 'serialize'
        *        using a stream with the same imbued locale and
        *        the same CharT and Traits.
        *        If the input cannot be deserialized,
        *        internal engine is left unchanged and failbit is raised on ist
        * \param ost The input stream to extract the data from
        */
        template<typename CharT, typename Traits>
        static void deserialize( std::basic_istream<CharT, Traits>& ist ) {
            ist >> engine_instance( );
        }

        /**
        * \brief Generate a random integer number in a [from; to] range
        *        by std::uniform_int_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random integer number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        static typename std::enable_if<details::is_uniform_int<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            if( from < to ) // Allow range from higher to lower
                return IntegerDist<T>{ from, to }( engine_instance( ) );
            return IntegerDist<T>{ to, from }( engine_instance( ) );
        }

        /**
        * \brief Generate a random real number in a [from; to] range
        *        by std::uniform_real_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random real number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        static typename std::enable_if<details::is_uniform_real<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            if( from < to ) // Allow range from higher to lower
                return RealDist<T>{ from, to }( engine_instance( ) );
            return RealDist<T>{ to, from }( engine_instance( ) );
        }

        /**
        * \brief Generate a random byte number in a [from; to] range
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random byte number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        static typename std::enable_if<details::is_byte<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            // Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                short, unsigned short>::type;

            return static_cast<T>( get<short_t>( from, to ) );
        }

        /**
        * \brief Generate a random common_type number in a [from; to] range
        * \param Key The Key type for this version of 'get' method
        *        Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random common_type number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Allow implicit type conversion
        * \note Prevent implicit type conversion from singed to unsigned types
        *       Why? std::common_type<Unsigned, Signed> chooses unsigned value,
        *                 then Signed value will be converted to Unsigned value
        *                       which gives us a wrong range for random values.
        *                           https://stackoverflow.com/a/5416498/5734836
        */
        template<
            typename Key,
            typename A,
            typename B, 
            typename C = typename std::common_type<A, B>::type
        >
        static typename std::enable_if<
               std::is_same<Key, common>::value
            && details::is_supported_number<A>::value
            && details::is_supported_number<B>::value
            // Prevent implicit type conversion from singed to unsigned types
            && std::is_signed<A>::value != std::is_unsigned<B>::value
            , C>::type get( A from = (std::numeric_limits<A>::min)( ),
                            B to = (std::numeric_limits<B>::max)( ) ) {
            return get( static_cast<C>( from ), static_cast<C>( to ) );
        }

        /**
        * \brief Generate a random character in a [from; to] range
        *        by std::uniform_int_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random character in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        static typename std::enable_if<details::is_supported_character<T>::value
            , T>::type get(T from = (std::numeric_limits<T>::min)(),
                T to = (std::numeric_limits<T>::max)()) {
            if (from < to) // Allow range from higher to lower
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from), static_cast<std::int64_t>(to) }(engine_instance()));
            return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to), static_cast<std::int64_t>(from) }(engine_instance()));
        }

        /**
        * \brief Generate a bool value with specific probability
        *                         by std::bernoulli_distribution
        * \param probability The probability of generating true in [0; 1] range
        *        0 means always false, 1 means always true
        * \return 'true' with 'probability' probability ('false' otherwise)
        */
        template<typename T>
        static typename std::enable_if<std::is_same<T, bool>::value
            , bool>::type get( const double probability = 0.5 ) {
            assert( 0 <= probability && 1 >= probability ); // out of [0; 1] range
            return BoolDist{ probability }( engine_instance( ) );
        }

        /**
        * \brief Return random value from initilizer_list
        * \param init_list initilizer_list with values
        * \return Random value from initilizer_list
        * \note Should be 1 or more elements in initilizer_list
        * \note Warning! Elements in initilizer_list can't be moved:
        *               https://stackoverflow.com/a/8193157/5734836
        */
        template<typename T>
        static T get( std::initializer_list<T> init_list ) {
            assert( 0u != init_list.size( ) );
            return *get( init_list.begin( ), init_list.end( ) );
        }

        /**
        * \brief Return random iterator from iterator range
        * \param first, last - the range of elements
        * \return Random iterator from [first, last) range
        * \note If first == last, return last
        */
        template<typename InputIt>
        static typename std::enable_if<details::is_iterator<InputIt>::value
            , InputIt>::type get( InputIt first, InputIt last ) {
            const auto size = std::distance( first, last );
            if( 0 == size ) return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next( first, get<diff_t>( 0, size - 1 ) );
        }

        /**
        * \brief Return random iterator from Container
        * \param container The container with elements
        * \return Random iterator from container
        * \note If container is empty return std::end( container ) iterator
        */
        template<typename Container>
        static auto get( Container& container ) -> 
            typename std::enable_if<details::is_iterator<
                decltype(std::begin(container))>::value
                , decltype(std::begin(container))
            >::type {
            return get( std::begin( container ), std::end( container ) );
        }

        /**
        * \brief Return container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        * \note Container "reserve" method will be called before generation
        */
        template<template<typename...> class Container, typename A>
        static typename std::enable_if<
                details::has_reserve<Container<A>>::value
            , Container<A>>::type get(A from, A to, std::size_t size) {
            Container<A> container;

            container.reserve(size);
            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get(from, to));

            return container;
        }

        /**
        * \brief Return container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        * \note Container "reserve" method will be called before generation
        */
        template<
            template<typename...> class Container,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        static typename std::enable_if<
                   std::is_same<Key, common>::value
                && details::has_reserve<Container<A>>::value
            , Container<C>>::type get(A start, B end, std::size_t size) {
            Container<C> container;

            container.reserve(size);
            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get<common>(start, end));

            return container;
        }

        /**
        * \brief Return container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<template<typename...> class Container, typename A>
        static typename std::enable_if<
              !details::has_reserve<Container<A>>::value
            , Container<A>>::type get(A start, A end, std::size_t size) {
            Container<A> container;

            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get(start, end));

            return container;
        }

        /**
        * \brief Return container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<
            template<typename...> class Container,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        static typename std::enable_if<
                 std::is_same<Key, common>::value
              && !details::has_reserve<Container<C>>::value
            , Container<C>>::type get(A start, B end, std::size_t size) {
            Container<C> container;

            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get<common>(start, end));

            return container;
        }

        /**
        * \brief Return array-like container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param N The number of elements in resulting container
        * \return Container filled with random values
        */
        template<template<typename AA, std::size_t NN, typename...> class Container, std::size_t N, typename A>
        static typename std::enable_if<
               !details::has_insert<Container<A, N>>::value
            , Container<A, N>>::type get(A start, A end) {
            Container<A, N> container = {{ 0 }};

            for (std::size_t i = 0; i < N; ++i)
                container[i] = get(start, end);

            return container;
        }

        /**
        * \brief Return array-like container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<
            template<typename AA, std::size_t NN, typename...> class Container,
            std::size_t N,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        static typename std::enable_if<
                  std::is_same<Key, common>::value
               && !details::has_insert<Container<C, N>>::value
            , Container<C, N>>::type get(A start, B end) {
            Container<C, N> container = {{ 0 }};

            for (std::size_t i = 0; i < N; ++i)
                container[i] = get<common>(start, end);

            return container;
        }

        /**
        * \brief Return random pointer from built-in array
        * \param array The built-in array with elements
        * \return Pointer to random element in array
        */
        template<typename T, std::size_t N>
        static T* get( T( &array )[ N ] ) {
            return std::addressof( array[ get<std::size_t>( 0, N - 1 ) ] );
        }

        /**
        * \brief Return value from custom Dist distribution
        *        seeded by internal random engine
        * \param Dist The type of custom distribution with next concept:
        *        http://en.cppreference.com/w/cpp/concept/RandomNumberDistribution
        * \param args The arguments which will be forwarded to Dist constructor
        * \return Value from custom distribution
        */
        template<typename Dist, typename... Args>
        static typename Dist::result_type get( Args&&... args ) {
            return Dist{ std::forward<Args>( args )... }( engine_instance( ) );
        }

        /**
        * \brief Return value from custom 'dist' distribution
        *        seeded by internal random engine
        * \param dist The custom distribution with next concept:
        *        http://en.cppreference.com/w/cpp/concept/RandomNumberDistribution
        * \param args The arguments which will be forwarded to Dist constructor
        * \return Value from custom 'dist' distribution
        */
        template<typename Dist>
        static typename Dist::result_type get( Dist& dist ) {
            return dist( engine_instance( ) );
        }

        /**
        * \brief Reorders the elements in the given range [first, last)
        *        such that each possible permutation of those elements
        *        has equal probability of appearance.
        * \param first, last - the range of elements to shuffle randomly       
        */
        template<typename RandomIt>
        static void shuffle( RandomIt first, RandomIt last ) {
            std::shuffle( first, last, engine_instance( ) );
        }

        /**
        * \brief Reorders the elements in the given container
        *        such that each possible permutation of those elements
        *        has equal probability of appearance.
        * \param container - the container with elements to shuffle randomly
        */
        template<typename Container>
        static void shuffle( Container& container ) {
            shuffle( std::begin( container ), std::end( container ) );
        }

        /// return internal engine by copy
        static Engine get_engine( ) {
            return engine_instance( );
        }

        /// return internal engine by ref
        static Engine& engine() {
            return engine_instance();
        }
    private:
        /// get reference to the thread local engine instance
        static Engine& engine_instance( ) {
            thread_local Engine engine{ Seeder{ }( ) };
            return engine;
        }
    };

    /**
    * \brief Base template class for random 
    *        with local API and local internal member storage
    * \note it IS thread safe but less efficient then 
    *                           basic_random_static
    * \param Engine A random engine with interface like in the std::mt19937
    * \param Seeder A seeder type which return seed for internal engine 
    *                                             through operator()
    */
    template<
        typename Engine,
        typename Seeder = seeder_default,
        template<typename> class IntegerDist = std::uniform_int_distribution,
        template<typename> class RealDist = std::uniform_real_distribution,
        typename BoolDist = std::bernoulli_distribution
    >
    class basic_random_local {
    public:
        /// Type of used random number engine
        using engine_type = Engine;

        /// Type of used random number seeder
        using seeder_type = Seeder;

        /// Type of used integer distribution
        template<typename T>
        using integer_dist_t = IntegerDist<T>;

        /// Type of used real distribution
        template<typename T>
        using real_dist_t = RealDist<T>;

        /// Type of used bool distribution
        using bool_dist_t = BoolDist;

        /// Key type for getting common type numbers or objects
        using common = details::common;

        /**
        * \return The minimum value
        * potentially generated by the random-number engine
        */
        static constexpr typename Engine::result_type (min)( ) {
            return (Engine::min)( );
        }

        /**
        * \return The maximum value
        * potentially generated by the random-number engine
        */
        static constexpr typename Engine::result_type (max)( ) {
            return (Engine::max)( );
        }

        /// Advances the internal state by z times
        void discard( const unsigned long long z ) {
            m_engine.discard( z );
        }

        /// Reseed by Seeder
        void reseed( ) {
            Seeder seeder;
            seed( seeder( ) );
        }

        /**
        * \brief Reinitializes the internal state
        * of the random-number engine using new seed value
        * \param value The seed value to use 
        *        in the initialization of the internal state
        */
        void seed( const typename Engine::result_type value =
                          Engine::default_seed ) {
            m_engine.seed( value );
        }

        /**
        * \brief Reinitializes the internal state
        * of the random-number engine using new seed value
        * \param seq The seed sequence 
        *        to use in the initialization of the internal state
        */
        template<typename Sseq>
        void seed( Sseq& seq ) {
            m_engine.seed( seq );
        }

        /// return random number from engine in [min(), max()] range
        typename Engine::result_type get( ) {
            return m_engine( );
        }

        /**
        * \brief Compares internal pseudo-random number engine
        *        with 'other' pseudo-random number engine.
        *        Two engines are equal, if their internal states
        *        are equivalent, that is, if they would generate
        *        equivalent values for any number of calls of operator()
        * \param other The engine, with which the internal engine will be compared
        * \return true, if other and internal engine are equal
        */
        bool is_equal( const Engine& other ) {
            return m_engine == other;
        }

        /**
        * \brief Serializes the internal state of the
        *        internal pseudo-random number engine as a sequence
        *        of decimal numbers separated by one or more spaces,
        *        and inserts it to the stream ost. The fill character
        *        and the formatting flags of the stream are
        *        ignored and unaffected.
        * \param ost The output stream to insert the data to
        */
        template<typename CharT, typename Traits>
        void serialize( std::basic_ostream<CharT, Traits>& ost ) {
            ost << m_engine;
        }

        /**
        * \brief Restores the internal state of the
        *        internal pseudo-random number engine from
        *        the serialized representation, which
        *        was created by an earlier call to 'serialize'
        *        using a stream with the same imbued locale and
        *        the same CharT and Traits.
        *        If the input cannot be deserialized,
        *        internal engine is left unchanged and failbit is raised on ist
        * \param ost The input stream to extract the data from
        */
        template<typename CharT, typename Traits>
        void deserialize( std::basic_istream<CharT, Traits>& ist ) {
            ist >> m_engine;
        }

        /**
        * \brief Generate a random integer number in a [from; to] range
        *        by std::uniform_int_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random integer number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        typename std::enable_if<details::is_uniform_int<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            if( from < to ) // Allow range from higher to lower
                return IntegerDist<T>{ from, to }( m_engine );
            return IntegerDist<T>{ to, from }( m_engine );
        }

        /**
        * \brief Generate a random real number in a [from; to] range
        *        by std::uniform_real_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random real number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        typename std::enable_if<details::is_uniform_real<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            if( from < to ) // Allow range from higher to lower
                return RealDist<T>{ from, to }( m_engine );
            return RealDist<T>{ to, from }( m_engine );
        }

        /**
        * \brief Generate a random byte number in a [from; to] range
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random byte number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        typename std::enable_if<details::is_byte<T>::value
            , T>::type get( T from = (std::numeric_limits<T>::min)( ),
                            T to = (std::numeric_limits<T>::max)( ) ) {
            // Choose between short and unsigned short for byte conversion
            using short_t = typename std::conditional<std::is_signed<T>::value,
                short, unsigned short>::type;

            return static_cast<T>( get<short_t>( from, to ) );
        }

        /**
        * \brief Generate a random common_type number in a [from; to] range
        * \param Key The Key type for this version of 'get' method
        *        Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random common_type number in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Allow implicit type conversion
        * \note Prevent implicit type conversion from singed to unsigned types
        *       Why? std::common_type<Unsigned, Signed> chooses unsigned value,
        *                 then Signed value will be converted to Unsigned value
        *                       which gives us a wrong range for random values.
        *                           https://stackoverflow.com/a/5416498/5734836
        */
        template<
            typename Key,
            typename A,
            typename B, 
            typename C = typename std::common_type<A, B>::type
        >
        typename std::enable_if<
               std::is_same<Key, common>::value
            && details::is_supported_number<A>::value
            && details::is_supported_number<B>::value
            // Prevent implicit type conversion from singed to unsigned types
            && std::is_signed<A>::value != std::is_unsigned<B>::value
            , C>::type get( A from = (std::numeric_limits<A>::min)( ),
                            B to = (std::numeric_limits<B>::max)( ) ) {
            return get( static_cast<C>( from ), static_cast<C>( to ) );
        }

        /**
        * \brief Generate a random character in a [from; to] range
        *        by std::uniform_int_distribution
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \return A random character in a [from; to] range
        * \note Allow both: 'from' <= 'to' and 'from' >= 'to'
        * \note Prevent implicit type conversion
        */
        template<typename T>
        typename std::enable_if<details::is_supported_character<T>::value
            , T>::type get(T from = (std::numeric_limits<T>::min)(),
                T to = (std::numeric_limits<T>::max)()) {
            if (from < to) // Allow range from higher to lower
                return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(from), static_cast<std::int64_t>(to) }(m_engine));
            return static_cast<T>(IntegerDist<std::int64_t>{ static_cast<std::int64_t>(to), static_cast<std::int64_t>(from) }(m_engine));
        }

        /**
        * \brief Generate a bool value with specific probability
        *                         by std::bernoulli_distribution
        * \param probability The probability of generating true in [0; 1] range
        *        0 means always false, 1 means always true
        * \return 'true' with 'probability' probability ('false' otherwise)
        */
        template<typename T>
        typename std::enable_if<std::is_same<T, bool>::value
            , bool>::type get( const double probability = 0.5 ) {
            assert( 0 <= probability && 1 >= probability ); // out of [0; 1] range
            return BoolDist{ probability }( m_engine );
        }

        /**
        * \brief Return random value from initilizer_list
        * \param init_list initilizer_list with values
        * \return Random value from initilizer_list
        * \note Should be 1 or more elements in initilizer_list
        * \note Warning! Elements in initilizer_list can't be moved:
        *               https://stackoverflow.com/a/8193157/5734836
        */
        template<typename T>
        T get( std::initializer_list<T> init_list ) {
            assert( 0u != init_list.size( ) );
            return *get( init_list.begin( ), init_list.end( ) );
        }

        /**
        * \brief Return random iterator from iterator range
        * \param first, last - the range of elements
        * \return Random iterator from [first, last) range
        * \note If first == last, return last
        */
        template<typename InputIt>
        typename std::enable_if<details::is_iterator<InputIt>::value
            , InputIt>::type get( InputIt first, InputIt last ) {
            const auto size = std::distance( first, last );
            if( 0 == size ) return last;
            using diff_t = typename std::iterator_traits<InputIt>::difference_type;
            return std::next( first, get<diff_t>( 0, size - 1 ) );
        }

        /**
        * \brief Return random iterator from Container
        * \param container The container with elements
        * \return Random iterator from container
        * \note If container is empty return std::end( container ) iterator
        */
        template<typename Container>
        auto get( Container& container ) -> 
            typename std::enable_if<details::is_iterator<
                decltype(std::begin(container))>::value
                , decltype(std::begin(container))
            >::type {
            return get( std::begin( container ), std::end( container ) );
        }

        /**
        * \brief Return container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        * \note Container "reserve" method will be called before generation
        */
        template<template<typename...> class Container, typename A>
        typename std::enable_if<
                details::has_reserve<Container<A>>::value
            , Container<A>>::type get(A from, A to, std::size_t size) {
            Container<A> container;

            container.reserve(size);
            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get(from, to));

            return container;
        }

        /**
        * \brief Return container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        * \note Container "reserve" method will be called before generation
        */
        template<
            template<typename...> class Container,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        typename std::enable_if<
                   std::is_same<Key, common>::value
                && details::has_reserve<Container<A>>::value
            , Container<C>>::type get(A start, B end, std::size_t size) {
            Container<C> container;

            container.reserve(size);
            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get<common>(start, end));

            return container;
        }

        /**
        * \brief Return container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<template<typename...> class Container, typename A>
        typename std::enable_if<
              !details::has_reserve<Container<A>>::value
            , Container<A>>::type get(A start, A end, std::size_t size) {
            Container<A> container;

            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get(start, end));

            return container;
        }

        /**
        * \brief Return container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<
            template<typename...> class Container,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        typename std::enable_if<
                 std::is_same<Key, common>::value
              && !details::has_reserve<Container<C>>::value
            , Container<C>>::type get(A start, B end, std::size_t size) {
            Container<C> container;

            for (std::size_t i = 0; i < size; ++i)
                container.insert(std::end(container), get<common>(start, end));

            return container;
        }

        /**
        * \brief Return array-like container filled with random values
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param N The number of elements in resulting container
        * \return Container filled with random values
        */
        template<template<typename AA, std::size_t NN, typename...> class Container, std::size_t N, typename A>
        typename std::enable_if<
               !details::has_insert<Container<A, N>>::value
            , Container<A, N>>::type get(A start, A end) {
            Container<A, N> container = {{ 0 }};

            for (std::size_t i = 0; i < N; ++i)
                container[i] = get(start, end);

            return container;
        }

        /**
        * \brief Return array-like container filled with random common_type values
        * \param Key The Key type for this version of 'get' method
        *     Type should be '(THIS_TYPE)::common' struct
        * \param from The first limit number of a random range
        * \param to The second limit number of a random range
        * \param size The number of elements in resulting container
        * \return Container filled with random values
        */
        template<
            template<typename AA, std::size_t NN, typename...> class Container,
            std::size_t N,
            typename Key,
            typename A,
            typename B,
            typename C = typename std::common_type<A, B>::type>
        typename std::enable_if<
                  std::is_same<Key, common>::value
               && !details::has_insert<Container<C, N>>::value
            , Container<C, N>>::type get(A start, B end) {
            Container<C, N> container = {{ 0 }};

            for (std::size_t i = 0; i < N; ++i)
                container[i] = get<common>(start, end);

            return container;
        }

        /**
        * \brief Return random pointer from built-in array
        * \param array The built-in array with elements
        * \return Pointer to random element in array
        */
        template<typename T, std::size_t N>
        T* get( T( &array )[ N ] ) {
            return std::addressof( array[ get<std::size_t>( 0, N - 1 ) ] );
        }

        /**
        * \brief Return value from custom Dist distribution
        *        seeded by internal random engine
        * \param Dist The type of custom distribution with next concept:
        *        http://en.cppreference.com/w/cpp/concept/RandomNumberDistribution
        * \param args The arguments which will be forwarded to Dist constructor
        * \return Value from custom distribution
        */
        template<typename Dist, typename... Args>
        typename Dist::result_type get( Args&&... args ) {
            return Dist{ std::forward<Args>( args )... }( m_engine );
        }

        /**
        * \brief Return value from custom 'dist' distribution
        *        seeded by internal random engine
        * \param dist The custom distribution with next concept:
        *        http://en.cppreference.com/w/cpp/concept/RandomNumberDistribution
        * \param args The arguments which will be forwarded to Dist constructor
        * \return Value from custom 'dist' distribution
        */
        template<typename Dist>
        typename Dist::result_type get( Dist& dist ) {
            return dist( m_engine );
        }

        /**
        * \brief Reorders the elements in the given range [first, last)
        *        such that each possible permutation of those elements
        *        has equal probability of appearance.
        * \param first, last - the range of elements to shuffle randomly       
        */
        template<typename RandomIt>
        void shuffle( RandomIt first, RandomIt last ) {
            std::shuffle( first, last, m_engine );
        }

        /**
        * \brief Reorders the elements in the given container
        *        such that each possible permutation of those elements
        *        has equal probability of appearance.
        * \param container - the container with elements to shuffle randomly
        */
        template<typename Container>
        void shuffle( Container& container ) {
            shuffle( std::begin( container ), std::end( container ) );
        }

        /// return internal engine by copy
        Engine get_engine( ) const {
            return m_engine;
        }

        /// return internal engine by ref
        Engine& engine() {
            return m_engine;
        }
    private:
        /// return engine seeded by Seeder
        static Engine make_seeded_engine( ) {
            // Make seeder instance for seed return by reference like std::seed_seq
            return Engine{ Seeder{ }( ) };
        }
    private:
        /// The random number engine
        Engine m_engine{ make_seeded_engine( ) };
    };

    /** 
    * \brief The basic static random alias based on a std::mt19937
    * \note It uses static methods API and data with static storage
    * \note Not thread safe but more prefomance
    */
    using random_static = basic_random_static<std::mt19937>;

    /**
    * \brief The basic static random alias based on a std::mt19937
    * \note It uses static methods API and data with thread_local storage
    * \note Thread safe but less performance
    */
    using random_thread_local = basic_random_thread_local<std::mt19937>;

    /**
    * \brief The basic static random alias based on a std::mt19937
    * \note It uses non static methods API and data with auto storage
    * \note Not thread safe. Should construct on the stack at local scope
    */
    using random_local = basic_random_local<std::mt19937>;

} // namespace effolkronium

#endif // #ifndef EFFOLKRONIUM_RANDOM_HPP
RIFFF WAVEfmt      D     LIST   INFOISFT   Lavf58.76.100 data  e]   eqoz, .   $,c  tG) z   W X  P .EbBq,     H   3 s =  diL  w 8   g z 9G;BYH ?Z  R    @\ p `f  `\Za    h fym  wgcfq@K!d~`M $ JE+ 9!7# !@&$I IB1C~mabILN eW{	X{(		qHnUH	a7zs
h	f a?z/n!B#r.}BUH   2P [ V  		>l|#=G +F  @Ny x %9NJ*J  iL s   =f	} st  _OAs E i94 f *d.m(   jL2K   >  F}P  w\ V   yDr?Cb )D]  n  )A3D  w y y y %  ,unZ/G6) ~     	 bpCV  G _   V e hi/w` hFG+  T`J` 9    m ~ !ZH.-i]92oZT J GGXc.%@       %  PVI6'        \`   # 7 L k@ T   /:O 7   f H Q 5 > ( 6 (      EZuz ~g /rrlv$ @  ' >   F 9 D9f_lg  ? = pnon^ _ z }   _oA P         M3x^   TOq~
D_c}7 A 6 6 (       +   q )  & | uwCMM^j   * +:_ h     / # "  2  
   r { IXBW> W   & B h~GXc e O H T E  r  wX*  *i P   08v  
    : R     w x i`3#< ! 8  . 
  ~       z' =   S j   m}* 5  #"  } l qYz b   R A e_*,: J w     $ ?]   g y d m   ^M5  
 ` ? } [ K,= ?    2   <  $     VP   e         = V s      Y[>;       C 7     ! 4   C Y  2 = O  ! ) ( , $ } g  cH O T     2 a  v   Z m ?4e1   8  9 " -  n h     D V  %    / ! <  q`O;uA +    , " / 0       E Z Xoy  }   h   X ? "     : 6 5 8 R \  KdRh7 D  
 fX|Q ;     m W w d q c    n r 8 B pNe?S^n 
 b a S L 4 ' +  U ?     I 2 7 $ u f D ; jn.?  , B  $   l r   hYB . f N d J =$Z E n_X ^   " >     D G        k 9   zfA5i n      @ _ QfCH  `BT 6   A ;   G Z   ?]@Ug n       -  {T > qg[ b i x 1 G    - + H bs       e      +  F 7  !    1   ] n U^  3 -   M <    y h fXti     ; Q ~  
  * . \ Y  {  -   2  G 3 }?7XX  v  9 U 3 Q  , B      [;:   +  */g z   v    d } 
   O U    	     iZ C         6 B  dw46 M   1 D nuw f a L  *        M O  # Y k  *   0 ( G : 1  Y D  6( ~ ,3$1     6 0    # !  ^ A )      c y  # >  3 2 @ FImg(    t a !  )  t f   V Q       V^
    m _   ]= e   ? 3 D Z J g _5     6 # |g      xul w    4pV i b q     ~ y C 6   fm%   : &   os'><]< c   ! C  C K \ V P A  o  m $ 1 9 F , :  d y ? N (  "    > 7 [ V G B y  }a q D W & = Q m  : & ?   I J   U @ )  p]gWI L   
  t  n |  %   . 8 A M N [ D P npp j       1 5 @ J 5 E   1 L ) C , @   	  |[ T     & ! G C x x @ G  2 # 8 Wj    /  t Y 2   
 b Z  
 hd$ ) ' 4 3 I l   4  ' C 9   oe  ? * ' . D H 8 7 & .   v   _oQ^0 :   ` a [F g   }s . & 7 = K   1 H s  C O        N F r z  2  9 h      "  1' ll' + q u Z ]   E H    z    sx  h { D [ ? J L P ) # sZB    W H    G Q _gv{  % $  ? ; Y V 3 6 * 3  & 
  O ` P [ 6+hQ5   X T      / < e 8 X {rse"     $  H ? h k F Q  (      , " +      # %      [ X S L   m c A >   ' \ b g e ~uO A H 9  Q N r v * 1 C F   	        ] K > 2       # %            #  , & 7 ! 0 	  : C   m o }ux   V [ A L  & $ : P e ! 2   2 &     C A     O S     J K O Q   ! "  ! (  4 < V ] > C        ( "    - + + #  	    3 8 Y c L [  &   # 4 3     4 1 . 0    P c k t !  #     + 1 2 C  "  C 5   
      ? D 1 7  %   N ; "      #     " . ? V b   *      R H B ; . 4  "   %     ' $ - !  	 , & ) (          !     B ? E B 	  f d ^ \ ( , ( 0       M Z   y  , 7         L ` k | , 9 ,  B * 	  6 F K Y 1 >  ( , : ) 5   " - 7 D > I 2 :  !     ? = W O       D E l m O Q  
     @ ; \ \   )  * '     4 / 	 . =       E F v y 8 ;   8 : ) ) & ! 3 /    m u / 9   %   . *   A 9 o h    	   5 = : G 2 ;  	 % " 7 4    t f  { 7 5 9 F : B WOYQ B R T a P U 4 0   Y U Q P     B H 
      6 0 _ c    
 # &     5 )   !  " & ! .   % }  E Q   ~ h v Z   )  ! 0 A ) <    R J M 8     Y m ~  - >     	    :   - J c J Z    <     # % g t 2 E   , 2     ; 4     , #  	 > L ; O    . : ?       + .   	 % ,   %    ' # 3 2    # J I             (  < 1   y. ? : G            % ?  H > ^ P ,   : <  "   > - < -           + ? * >    6 - 	  Q O > F , = 3 J      ? ? : @ & 0  & . $ % ; 6 3 *   . 7      ? ;  ~ Q L }~ 
 : A ( .      $ & 9 @ 3 <  	     = C   . - 4 8  '         1 6  
    !  F [ = H          ) : 1 A  $ ) &       4 4      g ~ C _     !    T c ] k ! '   E E S V ! $ !    P I      !  ( .  : 0 6 N ? Y      : .      ' ' ! b ] G A       	  ) 0        # % / =  ,      L P  "   a k ` b    	  
 # " F C (  	   7 / E C   7 4   2 0 \ a % *  	 ' '    # 	    %      	            = 1 M E    . " 2 1 ) &    1 6          
 	  * &                + 0 %       ) > E W S ] = >   "  7 / '    , 4 " (   * , H I J I * &   ? K 2 @  )  !     &       ) <  )   & ! < 4 7 ,    
     # ' 8 : ( & '          0 2 ' *       D E , *     * 3 $ +     " '              "  , ) $ (   ! '        	        ) + - .   	    + 7 - 8     * + 0 3  	 , , ! #    $ Q d 4 E  *         ; ? V Y = :      #    
 ( *    < = ` `             2 % : 1 % "   C J Z e  '    ' . . :  ,  #   A @ 2 3             9 >     C F H H ( %   $ /  (   !  3 - = 5           ) & 6 1     4 1 2 3   ' " 3 2                      
        # ! ' # , ,       , , N U G Q  (   = 9     C O Q ] + 0    	   % $     9 > ( +                 &     ! 7  1      &           ! # )     
    & 0 8 F # ,         	   #             * ,      
 %  !             $  0 *       
  + - ' '   1 5   	         "                 !            * & 2    	                                     # "     
            
        " (    
               "         @ D " &  + ( 1 -        '     	        
         2 3      
       " # 	     ) * ( & !   	   @ @ ; : , / @ K 5 C   ; D  )     ! "   9 = A J          	    
       
              
               "         
       "            0 3 1 2 
               *  %       	 
     $                         5 . C > - *          - %                     	              
                               
 	       	                                   	     	 
      
                              
         	     	  
  	                       	                         	      
                      
    
    	                           	               
   	                    (  &  	 	       
       
                                    	                    	                           
                       	                
                                                     
 	                           
                            
                     
   	        ! $           	      	 	                            	 
      
   	 
   	                                     
      
               	       
                            
             
 	               	    
      
                       	              
     	 	     
   	             	    	                  
    	   
                              	         
         	                        	           	      	                                                     	  	                  
               
                                                                       
 
          
                                                               	                 
                 	     	  	                       
                                    	              	    
                                                           	    
     	   
           	  	         	   
  	                                   	       
 
       	  
      	 	                       	                                               
 	  	        
 	  	                                                      
  	                                                            	                                                                                                	     	 	            	  
  
 	                                            
                                 
                                                            	  
  	         	                                                                                                                                                                                                                                                  	                                                                                                                                                           	                                                       	           	     
                 	                                                                                                                                                        
    	                
  	                                                                                                                              
  
                
  
                                                                                                                                                                                                           	  	                                                                                        	              	  	   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	  
  	                                                                                                                                                                                                                       	  	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             PNG

   IHDR   <      ,   sRGB    gAMA  a   	pHYs    od   IDATHKctJBD
x6E r4J>UEp0R q7	Ep KCG:^`:{ D"O\!,"
 dhB]w428Mf`  S:\,     IENDB`PNG

   IHDR   $   
   Sk   sRGB    gAMA  a   	pHYs    od   IDAT8Oc?  u,re@hG:_~*Da8 fe(. ea dw6XtS/&O@X4h".Ce|FS] \}    IENDB`PNG

   IHDR         H-   sRGB    gAMA  a   	pHYs    od   IDAT8Oc PL`OZ)(&
5==SgS0h~LL
@`h\h0Xx5\Q`=P% ktPAA0WM+h P ~:~d    IENDB`